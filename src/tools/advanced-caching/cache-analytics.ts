/** * CacheAnalytics - Comprehensive Cache Analytics * * Real-time analytics and reporting for cache performance and usage. * Provides visualization, trend analysis, alerting, and cost analysis capabilities. * * Operations: * 1. dashboard - Get real-time dashboard data * 2. metrics - Get detailed metrics * 3. trends - Analyze trends over time * 4. alerts - Configure and check alerts * 5. heatmap - Generate access heatmap * 6. bottlenecks - Identify performance bottlenecks * 7. cost-analysis - Analyze caching costs * 8. export-data - Export analytics data * * Token Reduction Target: 88%+ */ import { CacheEngine } from "../../core/cache-engine";
import { TokenCounter } from "../../core/token-counter";
import { MetricsCollector } from "../../core/metrics";
import { createWriteStream, existsSync } from "fs";
import { join } from "path";
import { createCanvas } from "canvas";
import { generateCacheKey } from "../shared/hash-utils";
import { Chart, registerables } from "chart"; // Register Chart.js componentsChart.register(...registerables);// ============================================================================// Type Definitions// ============================================================================export interface CacheAnalyticsOptions {  operation: 'dashboard' | 'metrics' | 'trends' | 'alerts' | 'heatmap' | 'bottlenecks' | 'cost-analysis' | 'export-data';  // Common options  timeRange?: { start: number; end: number };  granularity?: 'second' | 'minute' | 'hour' | 'day';  // Metrics operation  metricTypes?: Array<'performance' | 'usage' | 'efficiency' | 'cost' | 'health'>;  aggregation?: 'sum' | 'avg' | 'min' | 'max' | 'p95' | 'p99';  // Trends operation  compareWith?: 'previous-period' | 'last-week' | 'last-month';  trendType?: 'absolute' | 'percentage' | 'rate';  // Alerts operation  alertType?: 'threshold' | 'anomaly' | 'trend';  threshold?: number;  alertConfig?: AlertConfiguration;  // Heatmap operation  heatmapType?: 'temporal' | 'key-correlation' | 'memory';  resolution?: 'low' | 'medium' | 'high';  // Export operation  format?: 'json' | 'csv' | 'excel';  filePath?: string;  // Caching options  useCache?: boolean;  cacheTTL?: number;}export interface CacheAnalyticsResult {  success: boolean;  operation: string;  data: {    dashboard?: DashboardData;    metrics?: MetricCollection;    trends?: TrendAnalysis;    alerts?: Alert[];    heatmap?: HeatmapData;    bottlenecks?: Bottleneck[];    costAnalysis?: CostBreakdown;    exportPath?: string;  };  metadata: {    tokensUsed: number;    tokensSaved: number;    cacheHit: boolean;    executionTime: number;  };}// Dashboard Typesexport interface DashboardData {  timestamp: number;  performance: PerformanceMetrics;  usage: UsageMetrics;  efficiency: EfficiencyMetrics;  cost: CostMetrics;  health: HealthMetrics;  recentActivity: ActivityLog[];}export interface PerformanceMetrics {  hitRate: number;  latencyP50: number;  latencyP95: number;  latencyP99: number;  throughput: number;  operationsPerSecond: number;  averageResponseTime: number;}export interface UsageMetrics {  totalKeys: number;  totalSize: number;  keyAccessFrequency: Map<string, number>;  valueSizeDistribution: SizeDistribution;  topAccessedKeys: Array<{ key: string; hits: number }>;  recentlyAdded: Array<{ key: string; timestamp: number }>;}export interface EfficiencyMetrics {  memoryUtilization: number;  evictionRate: number;  evictionPatterns: EvictionPattern[];  compressionRatio: number;  fragmentationIndex: number;}export interface CostMetrics {  memoryCost: number;  diskCost: number;  networkCost: number;  totalCost: number;  costPerOperation: number;  costTrend: number;}export interface HealthMetrics {  errorRate: number;  timeoutRate: number;  fragmentationLevel: number;  warningCount: number;  criticalIssues: string[];  healthScore: number;}export interface ActivityLog {  timestamp: number;  operation: string;  key?: string;  duration: number;  status: 'success' | 'error' | 'timeout';}// Metrics Typesexport interface MetricCollection {  timestamp: number;  timeRange: { start: number; end: number };  performance?: PerformanceMetrics;  usage?: UsageMetrics;  efficiency?: EfficiencyMetrics;  cost?: CostMetrics;  health?: HealthMetrics;  aggregatedData: AggregatedMetrics;}export interface AggregatedMetrics {  totalOperations: number;  successfulOperations: number;  failedOperations: number;  averageDuration: number;  totalCacheHits: number;  totalCacheMisses: number;}// Trend Analysis Typesexport interface TrendAnalysis {  timestamp: number;  timeRange: { start: number; end: number };  metrics: TrendMetric[];  anomalies: Anomaly[];  predictions: Prediction[];  regression: RegressionResult;  seasonality: SeasonalityPattern;}export interface TrendMetric {  name: string;  current: number;  previous: number;  change: number;  changePercent: number;  trend: 'up' | 'down' | 'stable';  velocity: number;}export interface Anomaly {  timestamp: number;  metric: string;  value: number;  expected: number;  deviation: number;  severity: 'low' | 'medium' | 'high';  confidence: number;}export interface Prediction {  metric: string;  timestamp: number;  predictedValue: number;  confidenceInterval: { lower: number; upper: number };  confidence: number;}export interface RegressionResult {  slope: number;  intercept: number;  rSquared: number;  equation: string;}export interface SeasonalityPattern {  detected: boolean;  period: number;  strength: number;  peaks: number[];  troughs: number[];}// Alert Typesexport interface Alert {  id: string;  type: 'threshold' | 'anomaly' | 'trend';  metric: string;  severity: 'info' | 'warning' | 'critical';  message: string;  timestamp: number;  value: number;  threshold?: number;  triggered: boolean;}export interface AlertConfiguration {  metric: string;  condition: 'gt' | 'lt' | 'eq' | 'ne';  threshold: number;  severity: 'info' | 'warning' | 'critical';  enabled: boolean;}// Heatmap Typesexport interface HeatmapData {  type: 'temporal' | 'key-correlation' | 'memory';  dimensions: { width: number; height: number };  data: number[][];  labels: { x: string[]; y: string[] };  colorScale: { min: number; max: number };  visualization?: string; // Base64 encoded image}// Bottleneck Typesexport interface Bottleneck {  type: 'slow-operation' | 'hot-key' | 'memory-pressure' | 'high-eviction';  severity: 'low' | 'medium' | 'high';  description: string;  impact: number;  recommendation: string;  affectedKeys?: string[];  metrics: {    current: number;    threshold: number;    duration: number;  };}// Cost Analysis Typesexport interface CostBreakdown {  timestamp: number;  timeRange: { start: number; end: number };  storage: StorageCost;  network: NetworkCost;  compute: ComputeCost;  total: TotalCost;  projections: CostProjection[];  optimizations: CostOptimization[];}export interface StorageCost {  memoryCost: number;  diskCost: number;  totalStorage: number;  utilizationPercent: number;}export interface NetworkCost {  ingressCost: number;  egressCost: number;  totalTraffic: number;  bandwidthUtilization: number;}export interface ComputeCost {  cpuCost: number;  operationCost: number;  totalOperations: number;  efficiency: number;}export interface TotalCost {  current: number;  projected: number;  trend: number;  costPerGB: number;  costPerOperation: number;}export interface CostProjection {  period: string;  estimatedCost: number;  confidence: number;}export interface CostOptimization {  category: string;  potentialSavings: number;  effort: 'low' | 'medium' | 'high';  recommendation: string;}// Supporting Typesexport interface SizeDistribution {  small: number; // < 1KB  medium: number; // 1KB - 10KB  large: number; // 10KB - 100KB  xlarge: number; // > 100KB}export interface EvictionPattern {  reason: string;  count: number;  percentage: number;  trend: 'increasing' | 'stable' | 'decreasing';}// ============================================================================// Main Implementation// ============================================================================export class CacheAnalytics {  private cache: CacheEngine;  private tokenCounter: TokenCounter;  private metricsCollector: MetricsCollector;  private alertConfigs: Map<string, AlertConfiguration> = new Map();  private historicalData: Map<number, DashboardData> = new Map();  constructor(    cache: CacheEngine,    tokenCounter: TokenCounter,    metricsCollector: MetricsCollector  ) {    this.cache = cache;    this.tokenCounter = tokenCounter;    this.metricsCollector = metricsCollector;    this.initializeDefaults();  }  /**   * Initialize default alert configurations   */  private initializeDefaults(): void {    // Default alert configurations    this.alertConfigs.set('high-error-rate', {      metric: 'errorRate',      condition: 'gt',      threshold: 5.0,      severity: 'critical',      enabled: true    });    this.alertConfigs.set('low-hit-rate', {      metric: 'hitRate',      condition: 'lt',      threshold: 70.0,      severity: 'warning',      enabled: true    });    this.alertConfigs.set('high-latency', {      metric: 'latencyP95',      condition: 'gt',      threshold: 100.0,      severity: 'warning',      enabled: true    });  }  /**   * Main entry point for cache analytics operations   */  async run(options: CacheAnalyticsOptions): Promise<CacheAnalyticsResult> {    const startTime = Date.now();    // Generate cache key    const cacheKey = generateCacheKey('cache-analytics', {        op: options.operation,        time: options.timeRange,        gran: options.granularity      });    // Check cache if enabled    if (options.useCache !== false) {      const cached = this.cache.get(cacheKey);      if (cached) {        try {          const data = JSON.parse(cached.toString());          const tokenCountResult = this.tokenCounter.count(JSON.stringify(data));          const tokensSaved = tokenCountResult.tokens;          return {            success: true,            operation: options.operation,            data,            metadata: {              tokensUsed: 0,              tokensSaved,              cacheHit: true,              executionTime: Date.now() - startTime            }          };        } catch (error) {          // Cache parse error, continue with fresh execution        }      }    }    // Execute operation    let data: CacheAnalyticsResult['data'];    try {      switch (options.operation) {        case 'dashboard':          data = { dashboard: await this.getDashboard(options) };          break;        case 'metrics':          data = { metrics: await this.getMetrics(options) };          break;        case 'trends':          data = { trends: await this.analyzeTrends(options) };          break;        case 'alerts':          data = { alerts: await this.checkAlerts(options) };          break;        case 'heatmap':          data = { heatmap: await this.generateHeatmap(options) };          break;        case 'bottlenecks':          data = { bottlenecks: await this.identifyBottlenecks(options) };          break;        case 'cost-analysis':          data = { costAnalysis: await this.analyzeCosts(options) };          break;        case 'export-data':          data = { exportPath: await this.exportData(options) };          break;        default:          throw new Error(`Unknown operation: ${options.operation}`);      }    } catch (error) {      const errorMsg = error instanceof Error ? error.message : String(error);      return {        success: false,        operation: options.operation,        data: {},        metadata: {          tokensUsed: 0,          tokensSaved: 0,          cacheHit: false,          executionTime: Date.now() - startTime        }      };    }    // Calculate tokens and cache result    const tokenCountResult = this.tokenCounter.count(JSON.stringify(data));    const tokensUsed = tokenCountResult.tokens;    const cacheTTL = options.cacheTTL || 30; // 30 seconds default for dashboard    this.cache.set(cacheKey, JSON.stringify(data), tokensUsed, cacheTTL);    // Record metrics    this.metricsCollector.record({      operation: `analytics-${options.operation}`,      duration: Date.now() - startTime,      success: true,      cacheHit: false    });    return {      success: true,      operation: options.operation,      data,      metadata: {        tokensUsed,        tokensSaved: 0,        cacheHit: false,        executionTime: Date.now() - startTime      }    };  }  // ============================================================================  // Dashboard Operations  // ============================================================================  /**   * Get real-time dashboard data   */  private async getDashboard(options: CacheAnalyticsOptions): Promise<DashboardData> {    const now = Date.now();    const timeRange = options.timeRange || { start: now - 3600000, end: now }; // Last hour    // Gather all metrics    const performance = this.getPerformanceMetrics(timeRange);    const usage = this.getUsageMetrics(timeRange);    const efficiency = this.getEfficiencyMetrics(timeRange);    const cost = this.getCostMetrics(timeRange);    const health = this.getHealthMetrics(timeRange);    const recentActivity = this.getRecentActivity(10);    const dashboard: DashboardData = {      timestamp: now,      performance,      usage,      efficiency,      cost,      health,      recentActivity    };    // Store for trend analysis    this.historicalData.set(now, dashboard);    if (this.historicalData.size > 1000) {      const oldestKey = Array.from(this.historicalData.keys()).sort((a, b) => a - b)[0];      this.historicalData.delete(oldestKey);    }    return dashboard;  }  /**   * Get performance metrics   */  private getPerformanceMetrics(timeRange: { start: number; end: number }): PerformanceMetrics {    const stats = this.metricsCollector.getCacheStats(timeRange.start);    const percentiles = this.metricsCollector.getPerformancePercentiles(timeRange.start);    const duration = (timeRange.end - timeRange.start) / 1000;    return {      hitRate: stats.cacheHitRate,      latencyP50: percentiles.p50,      latencyP95: percentiles.p95,      latencyP99: percentiles.p99,      throughput: stats.totalOperations / duration,      operationsPerSecond: stats.totalOperations / duration,      averageResponseTime: stats.averageDuration    };  }  /**   * Get usage metrics   */  private getUsageMetrics(timeRange: { start: number; end: number }): UsageMetrics {    const cacheStats = this.cache.getStats();    const operations = this.metricsCollector.getOperations(timeRange.start);    // Calculate key access frequency    const keyAccessFrequency = new Map<string, number>();    operations.forEach(op => {      if (op.operation.includes('get') || op.operation.includes('set')) {        const key = this.extractKeyFromOperation(op.operation);        keyAccessFrequency.set(key, (keyAccessFrequency.get(key) || 0) + 1);      }    });    // Get top accessed keys    const topAccessedKeys = Array.from(keyAccessFrequency.entries())      .sort((a, b) => b[1] - a[1])      .slice(0, 10)      .map(([key, hits]) => ({ key, hits }));    // Size distribution (simulated)    const valueSizeDistribution: SizeDistribution = {      small: Math.floor(cacheStats.totalEntries * 0.6),      medium: Math.floor(cacheStats.totalEntries * 0.25),      large: Math.floor(cacheStats.totalEntries * 0.1),      xlarge: Math.floor(cacheStats.totalEntries * 0.05)    };    return {      totalKeys: cacheStats.totalEntries,      totalSize: cacheStats.totalCompressedSize,      keyAccessFrequency,      valueSizeDistribution,      topAccessedKeys,      recentlyAdded: []    };  }  /**   * Get efficiency metrics   */  private getEfficiencyMetrics(timeRange: { start: number; end: number }): EfficiencyMetrics {    const cacheStats = this.cache.getStats();    const operations = this.metricsCollector.getOperations(timeRange.start);    // Calculate eviction rate    const evictionOps = operations.filter(op => op.operation.includes('evict')).length;    const totalOps = operations.length || 1;    const evictionRate = (evictionOps / totalOps) * 100;    // Eviction patterns (simulated)    const evictionPatterns: EvictionPattern[] = [      { reason: 'TTL Expired', count: Math.floor(evictionOps * 0.5), percentage: 50, trend: 'stable' },      { reason: 'Size Limit', count: Math.floor(evictionOps * 0.3), percentage: 30, trend: 'increasing' },      { reason: 'Manual', count: Math.floor(evictionOps * 0.2), percentage: 20, trend: 'stable' }    ];    return {      memoryUtilization: (cacheStats.totalCompressedSize / (500 * 1024 * 1024)) * 100, // Assuming 500MB max      evictionRate,      evictionPatterns,      compressionRatio: cacheStats.compressionRatio,      fragmentationIndex: this.calculateFragmentation()    };  }  /**   * Get cost metrics   */  private getCostMetrics(timeRange: { start: number; end: number }): CostMetrics {    const cacheStats = this.cache.getStats();    const operations = this.metricsCollector.getOperations(timeRange.start);    // Cost calculations (simulated pricing)    const memoryCostPerGB = 0.10; // $0.10 per GB-hour    const diskCostPerGB = 0.02; // $0.02 per GB-hour    const networkCostPerGB = 0.05; // $0.05 per GB    const operationCost = 0.000001; // $0.000001 per operation    const memoryGB = cacheStats.totalCompressedSize / (1024 * 1024 * 1024);    const hours = (timeRange.end - timeRange.start) / 3600000;    const memoryCost = memoryGB * memoryCostPerGB * hours;    const diskCost = memoryGB * diskCostPerGB * hours;    const networkCost = memoryGB * networkCostPerGB;    const totalCost = memoryCost + diskCost + networkCost + (operations.length * operationCost);    return {      memoryCost,      diskCost,      networkCost,      totalCost,      costPerOperation: totalCost / (operations.length || 1),      costTrend: 0 // Calculate from historical data    };  }  /**   * Get health metrics   */  private getHealthMetrics(timeRange: { start: number; end: number }): HealthMetrics {    const operations = this.metricsCollector.getOperations(timeRange.start);    const stats = this.metricsCollector.getCacheStats(timeRange.start);    const errorOps = operations.filter(op => !op.success).length;    const timeoutOps = operations.filter(op => op.duration > 1000).length;    const totalOps = operations.length || 1;    const errorRate = (errorOps / totalOps) * 100;    const timeoutRate = (timeoutOps / totalOps) * 100;    const criticalIssues: string[] = [];    if (errorRate > 5) criticalIssues.push(`High error rate: ${errorRate.toFixed(2)}%`);    if (timeoutRate > 10) criticalIssues.push(`High timeout rate: ${timeoutRate.toFixed(2)}%`);    if (stats.cacheHitRate < 50) criticalIssues.push(`Low cache hit rate: ${stats.cacheHitRate.toFixed(2)}%`);    // Calculate health score (0-100)    const healthScore = Math.max(0, 100 - (errorRate * 2) - (timeoutRate * 1.5) - ((100 - stats.cacheHitRate) * 0.5));    return {      errorRate,      timeoutRate,      fragmentationLevel: this.calculateFragmentation(),      warningCount: criticalIssues.length,      criticalIssues,      healthScore    };  }  /**   * Get recent activity   */  private getRecentActivity(limit: number): ActivityLog[] {    const operations = this.metricsCollector.getOperations();    return operations.slice(-limit).map(op => ({      timestamp: op.timestamp,      operation: op.operation,      duration: op.duration,      status: op.success ? 'success' : 'error'    }));  }  // ============================================================================  // Metrics Operations  // ============================================================================  /**   * Get detailed metrics   */  private async getMetrics(options: CacheAnalyticsOptions): Promise<MetricCollection> {    const now = Date.now();    const timeRange = options.timeRange || { start: now - 3600000, end: now };    const operations = this.metricsCollector.getOperations(timeRange.start);    const metricTypes = options.metricTypes || ['performance', 'usage', 'efficiency', 'cost', 'health'];    const metrics: Partial<MetricCollection> = {      timestamp: now,      timeRange    };    if (metricTypes.includes('performance')) {      metrics.performance = this.getPerformanceMetrics(timeRange);    }    if (metricTypes.includes('usage')) {      metrics.usage = this.getUsageMetrics(timeRange);    }    if (metricTypes.includes('efficiency')) {      metrics.efficiency = this.getEfficiencyMetrics(timeRange);    }    if (metricTypes.includes('cost')) {      metrics.cost = this.getCostMetrics(timeRange);    }    if (metricTypes.includes('health')) {      metrics.health = this.getHealthMetrics(timeRange);    }    // Aggregated data    const successfulOps = operations.filter(op => op.success).length;    const failedOps = operations.length - successfulOps;    const totalDuration = operations.reduce((sum, op) => sum + op.duration, 0);    const cacheHits = operations.filter(op => op.cacheHit).length;    metrics.aggregatedData = {      totalOperations: operations.length,      successfulOperations: successfulOps,      failedOperations: failedOps,      averageDuration: totalDuration / (operations.length || 1),      totalCacheHits: cacheHits,      totalCacheMisses: operations.length - cacheHits    };    return metrics as MetricCollection;  }  // ============================================================================  // Trend Analysis Operations  // ============================================================================  /**   * Analyze trends over time   */  private async analyzeTrends(options: CacheAnalyticsOptions): Promise<TrendAnalysis> {    const now = Date.now();    const timeRange = options.timeRange || { start: now - 86400000, end: now }; // Last 24 hours    // Get current and previous period data    const currentPeriod = this.metricsCollector.getCacheStats(timeRange.start);    const previousStart = timeRange.start - (timeRange.end - timeRange.start);    const previousPeriod = this.metricsCollector.getCacheStats(previousStart);    // Calculate trend metrics    const metrics: TrendMetric[] = [      this.calculateTrendMetric('Hit Rate', currentPeriod.cacheHitRate, previousPeriod.cacheHitRate),      this.calculateTrendMetric('Operations', currentPeriod.totalOperations, previousPeriod.totalOperations),      this.calculateTrendMetric('Avg Duration', currentPeriod.averageDuration, previousPeriod.averageDuration),      this.calculateTrendMetric('Success Rate', currentPeriod.successRate, previousPeriod.successRate)    ];    // Detect anomalies    const anomalies = this.detectAnomalies(timeRange);    // Generate predictions    const predictions = this.generatePredictions(timeRange);    // Perform regression analysis    const regression = this.performRegression(timeRange);    // Detect seasonality    const seasonality = this.detectSeasonality(timeRange);    return {      timestamp: now,      timeRange,      metrics,      anomalies,      predictions,      regression,      seasonality    };  }  /**   * Calculate trend metric   */  private calculateTrendMetric(name: string, current: number, previous: number): TrendMetric {    const change = current - previous;    const changePercent = previous !== 0 ? (change / previous) * 100 : 0;    const trend = Math.abs(changePercent) < 5 ? 'stable' : (changePercent > 0 ? 'up' : 'down');    const velocity = changePercent / 100; // Rate of change    return {      name,      current,      previous,      change,      changePercent,      trend,      velocity    };  }  /**   * Detect anomalies in metrics   */  private detectAnomalies(timeRange: { start: number; end: number }): Anomaly[] {    const operations = this.metricsCollector.getOperations(timeRange.start);    const anomalies: Anomaly[] = [];    if (operations.length === 0) return anomalies;    // Calculate statistics    const durations = operations.map(op => op.duration);    const mean = durations.reduce((a, b) => a + b, 0) / durations.length;    const variance = durations.reduce((sum, d) => sum + Math.pow(d - mean, 2), 0) / durations.length;    const stdDev = Math.sqrt(variance);    // Detect anomalous operations (> 3 standard deviations)    operations.forEach(op => {      const deviation = Math.abs(op.duration - mean) / stdDev;      if (deviation > 3) {        anomalies.push({          timestamp: op.timestamp,          metric: 'duration',          value: op.duration,          expected: mean,          deviation: deviation,          severity: deviation > 5 ? 'high' : 'medium',          confidence: Math.min(0.99, deviation / 5)        });      }    });    return anomalies.slice(0, 10); // Top 10 anomalies  }  /**   * Generate predictions   */  private generatePredictions(timeRange: { start: number; end: number }): Prediction[] {    const operations = this.metricsCollector.getOperations(timeRange.start);    if (operations.length < 10) return [];    // Simple linear prediction    const durations = operations.map(op => op.duration);    const mean = durations.reduce((a, b) => a + b, 0) / durations.length;    const stdDev = Math.sqrt(durations.reduce((sum, d) => sum + Math.pow(d - mean, 2), 0) / durations.length);    const predictions: Prediction[] = [];    const now = Date.now();    // Predict next hour    for (let i = 1; i <= 4; i++) {      const timestamp = now + (i * 900000); // 15 minute intervals      predictions.push({        metric: 'duration',        timestamp,        predictedValue: mean,        confidenceInterval: {          lower: mean - (2 * stdDev),          upper: mean + (2 * stdDev)        },        confidence: 0.95      });    }    return predictions;  }  /**   * Perform linear regression   */  private performRegression(timeRange: { start: number; end: number }): RegressionResult {    const operations = this.metricsCollector.getOperations(timeRange.start);    if (operations.length < 2) {      return {        slope: 0,        intercept: 0,        rSquared: 0,        equation: 'y = 0'      };    }    // Simple linear regression on operation count over time    const points = operations.map((op, i) => ({ x: i, y: op.duration }));    const n = points.length;    const sumX = points.reduce((sum, p) => sum + p.x, 0);    const sumY = points.reduce((sum, p) => sum + p.y, 0);    const sumXY = points.reduce((sum, p) => sum + (p.x * p.y), 0);    const sumX2 = points.reduce((sum, p) => sum + (p.x * p.x), 0);    const sumY2 = points.reduce((sum, p) => sum + (p.y * p.y), 0);    const slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);    const intercept = (sumY - slope * sumX) / n;    // Calculate R-squared    const yMean = sumY / n;    const ssTotal = points.reduce((sum, p) => sum + Math.pow(p.y - yMean, 2), 0);    const ssResidual = points.reduce((sum, p) => sum + Math.pow(p.y - (slope * p.x + intercept), 2), 0);    const rSquared = 1 - (ssResidual / ssTotal);    return {      slope,      intercept,      rSquared,      equation: `y = ${slope.toFixed(4)}x + ${intercept.toFixed(4)}`    };  }  /**   * Detect seasonality patterns   */  private detectSeasonality(timeRange: { start: number; end: number }): SeasonalityPattern {    const operations = this.metricsCollector.getOperations(timeRange.start);    if (operations.length < 24) {      return {        detected: false,        period: 0,        strength: 0,        peaks: [],        troughs: []      };    }    // Group by hour to detect daily patterns    const hourlyData = new Array(24).fill(0);    operations.forEach(op => {      const hour = new Date(op.timestamp).getHours();      hourlyData[hour]++;    });    // Find peaks and troughs    const mean = hourlyData.reduce((a, b) => a + b, 0) / hourlyData.length;    const peaks: number[] = [];    const troughs: number[] = [];    hourlyData.forEach((count, hour) => {      if (count > mean * 1.5) peaks.push(hour);      if (count < mean * 0.5) troughs.push(hour);    });    const strength = peaks.length > 0 || troughs.length > 0 ? 0.7 : 0;    return {      detected: peaks.length > 0 || troughs.length > 0,      period: 24, // Daily pattern      strength,      peaks,      troughs    };  }  // ============================================================================  // Alert Operations  // ============================================================================  /**   * Check and generate alerts   */  private async checkAlerts(options: CacheAnalyticsOptions): Promise<Alert[]> {    const alerts: Alert[] = [];    const now = Date.now();    const timeRange = options.timeRange || { start: now - 3600000, end: now };    // Add custom alert config if provided    if (options.alertConfig) {      this.alertConfigs.set(        `custom-${options.alertConfig.metric}`,        options.alertConfig      );    }    // Get current metrics    const health = this.getHealthMetrics(timeRange);    const performance = this.getPerformanceMetrics(timeRange);    // Check each alert configuration    for (const [id, config] of Array.from(this.alertConfigs.entries())) {      if (!config.enabled) continue;      let currentValue = 0;      let metricName = config.metric;      // Get metric value      switch (config.metric) {        case 'errorRate':          currentValue = health.errorRate;          break;        case 'hitRate':          currentValue = performance.hitRate;          break;        case 'latencyP95':          currentValue = performance.latencyP95;          break;        default:          continue;      }      // Check condition      let triggered = false;      switch (config.condition) {        case 'gt':          triggered = currentValue > config.threshold;          break;        case 'lt':          triggered = currentValue < config.threshold;          break;        case 'eq':          triggered = currentValue === config.threshold;          break;        case 'ne':          triggered = currentValue !== config.threshold;          break;      }      if (triggered) {        alerts.push({          id,          type: 'threshold',          metric: metricName,          severity: config.severity,          message: `${metricName} (${currentValue.toFixed(2)}) ${config.condition} threshold (${config.threshold})`,          timestamp: now,          value: currentValue,          threshold: config.threshold,          triggered: true        });      }    }    // Check for anomaly alerts    const anomalies = this.detectAnomalies(timeRange);    anomalies.forEach(anomaly => {      if (anomaly.severity === 'high') {        alerts.push({          id: `anomaly-${anomaly.timestamp}`,          type: 'anomaly',          metric: anomaly.metric,          severity: 'warning',          message: `Anomaly detected in ${anomaly.metric}: ${anomaly.value.toFixed(2)} (expected ${anomaly.expected.toFixed(2)})`,          timestamp: anomaly.timestamp,          value: anomaly.value,          triggered: true        });      }    });    return alerts;  }  // ============================================================================  // Heatmap Operations  // ============================================================================  /**   * Generate access heatmap   */  private async generateHeatmap(options: CacheAnalyticsOptions): Promise<HeatmapData> {    const heatmapType = options.heatmapType || 'temporal';    const resolution = options.resolution || 'medium';    switch (heatmapType) {      case 'temporal':        return this.generateTemporalHeatmap(resolution);      case 'key-correlation':        return this.generateKeyCorrelationHeatmap(resolution);      case 'memory':        return this.generateMemoryHeatmap(resolution);      default:        throw new Error(`Unknown heatmap type: ${heatmapType}`);    }  }  /**   * Generate temporal access heatmap (hour x day)   */  private async generateTemporalHeatmap(resolution: string): Promise<HeatmapData> {    const now = Date.now();    const operations = this.metricsCollector.getOperations(now - 604800000); // Last 7 days    // Create 7-day x 24-hour grid    const data: number[][] = Array(7).fill(0).map(() => Array(24).fill(0));    const dayLabels = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];    const hourLabels = Array.from({ length: 24 }, (_, i) => `${i}:00`);    operations.forEach(op => {      const date = new Date(op.timestamp);      const day = date.getDay();      const hour = date.getHours();      data[day][hour]++;    });    // Find min/max for color scale    const flatData = data.flat();    const min = Math.min(...flatData);    const max = Math.max(...flatData);    // Generate visualization    const visualization = await this.renderHeatmapChart(data, dayLabels, hourLabels);    return {      type: 'temporal',      dimensions: { width: 24, height: 7 },      data,      labels: { x: hourLabels, y: dayLabels },      colorScale: { min, max },      visualization    };  }  /**   * Generate key correlation heatmap   */  private async generateKeyCorrelationHeatmap(resolution: string): Promise<HeatmapData> {    const operations = this.metricsCollector.getOperations();    const keys = new Set<string>();    operations.forEach(op => {      const key = this.extractKeyFromOperation(op.operation);      if (key) keys.add(key);    });    const keyList = Array.from(keys).slice(0, 20); // Top 20 keys    const size = keyList.length;    const data: number[][] = Array(size).fill(0).map(() => Array(size).fill(0));    // Calculate correlation (co-occurrence in operations)    operations.forEach(op => {      const key = this.extractKeyFromOperation(op.operation);      if (key) {        const idx = keyList.indexOf(key);        if (idx >= 0) {          data[idx][idx]++;        }      }    });    const flatData = data.flat();    const min = Math.min(...flatData);    const max = Math.max(...flatData);    return {      type: 'key-correlation',      dimensions: { width: size, height: size },      data,      labels: { x: keyList, y: keyList },      colorScale: { min, max }    };  }  /**   * Generate memory usage heatmap   */  private async generateMemoryHeatmap(resolution: string): Promise<HeatmapData> {    const stats = this.cache.getStats();    // Simulate memory distribution across time    const hours = 24;    const categories = ['L1 Cache', 'L2 Cache', 'L3 Cache', 'Overflow'];    const data: number[][] = Array(categories.length).fill(0).map(() =>      Array(hours).fill(0).map(() => Math.random() * stats.totalCompressedSize / 4)    );    const hourLabels = Array.from({ length: hours }, (_, i) => `${i}:00`);    const flatData = data.flat();    const min = Math.min(...flatData);    const max = Math.max(...flatData);    return {      type: 'memory',      dimensions: { width: hours, height: categories.length },      data,      labels: { x: hourLabels, y: categories },      colorScale: { min, max }    };  }  /**   * Render heatmap as chart image   */  private async renderHeatmapChart(    data: number[][],    xLabels: string[],    yLabels: string[]  ): Promise<string> {    const width = 800;    const height = 400;    const canvas = createCanvas(width, height);    const ctx = canvas.getContext('2d');    // Create gradient for heatmap colors    const flatData = data.flat();    const max = Math.max(...flatData);    // Draw heatmap    const cellWidth = width / xLabels.length;    const cellHeight = height / yLabels.length;    data.forEach((row, y) => {      row.forEach((value, x) => {        const intensity = max > 0 ? value / max : 0;        ctx.fillStyle = this.getHeatmapColor(intensity);        ctx.fillRect(x * cellWidth, y * cellHeight, cellWidth, cellHeight);      });    });    // Convert to base64    return canvas.toDataURL();  }  /**   * Get heatmap color based on intensity   */  private getHeatmapColor(intensity: number): string {    const r = Math.floor(255 * intensity);    const g = Math.floor(128 * (1 - intensity));    const b = Math.floor(64 * (1 - intensity));    return `rgb(${r},${g},${b})`;  }  // ============================================================================  // Bottleneck Operations  // ============================================================================  /**   * Identify performance bottlenecks   */  private async identifyBottlenecks(options: CacheAnalyticsOptions): Promise<Bottleneck[]> {    const bottlenecks: Bottleneck[] = [];    const now = Date.now();    const timeRange = options.timeRange || { start: now - 3600000, end: now };    const operations = this.metricsCollector.getOperations(timeRange.start);    const performance = this.getPerformanceMetrics(timeRange);    const efficiency = this.getEfficiencyMetrics(timeRange);    // Check for slow operations    if (performance.latencyP95 > 100) {      const slowOps = operations.filter(op => op.duration > 100);      bottlenecks.push({        type: 'slow-operation',        severity: performance.latencyP95 > 200 ? 'high' : 'medium',        description: `P95 latency is ${performance.latencyP95.toFixed(2)}ms`,        impact: (performance.latencyP95 - 100) / 100,        recommendation: 'Optimize slow operations or increase cache TTL',        affectedKeys: slowOps.slice(0, 5).map(op => this.extractKeyFromOperation(op.operation)),        metrics: {          current: performance.latencyP95,          threshold: 100,          duration: timeRange.end - timeRange.start        }      });    }    // Check for hot keys    const keyAccessCounts = new Map<string, number>();    operations.forEach(op => {      const key = this.extractKeyFromOperation(op.operation);      if (key) {        keyAccessCounts.set(key, (keyAccessCounts.get(key) || 0) + 1);      }    });    const hotKeys = Array.from(keyAccessCounts.entries())      .filter(([_, count]) => count > operations.length * 0.1)      .sort((a, b) => b[1] - a[1]);    if (hotKeys.length > 0) {      bottlenecks.push({        type: 'hot-key',        severity: 'medium',        description: `${hotKeys.length} hot keys detected`,        impact: hotKeys[0][1] / operations.length,        recommendation: 'Consider partitioning or replication for hot keys',        affectedKeys: hotKeys.slice(0, 5).map(([key]) => key),        metrics: {          current: hotKeys[0][1],          threshold: operations.length * 0.1,          duration: timeRange.end - timeRange.start        }      });    }    // Check for memory pressure    if (efficiency.memoryUtilization > 80) {      bottlenecks.push({        type: 'memory-pressure',        severity: efficiency.memoryUtilization > 90 ? 'high' : 'medium',        description: `Memory utilization is ${efficiency.memoryUtilization.toFixed(2)}%`,        impact: efficiency.memoryUtilization / 100,        recommendation: 'Increase cache size or implement more aggressive eviction',        metrics: {          current: efficiency.memoryUtilization,          threshold: 80,          duration: timeRange.end - timeRange.start        }      });    }    // Check for high eviction rate    if (efficiency.evictionRate > 10) {      bottlenecks.push({        type: 'high-eviction',        severity: efficiency.evictionRate > 20 ? 'high' : 'medium',        description: `Eviction rate is ${efficiency.evictionRate.toFixed(2)}%`,        impact: efficiency.evictionRate / 100,        recommendation: 'Review TTL settings or increase cache capacity',        metrics: {          current: efficiency.evictionRate,          threshold: 10,          duration: timeRange.end - timeRange.start        }      });    }    return bottlenecks;  }  // ============================================================================  // Cost Analysis Operations  // ============================================================================  /**   * Analyze caching costs   */  private async analyzeCosts(options: CacheAnalyticsOptions): Promise<CostBreakdown> {    const now = Date.now();    const timeRange = options.timeRange || { start: now - 2592000000, end: now }; // Last 30 days    const cacheStats = this.cache.getStats();    const operations = this.metricsCollector.getOperations(timeRange.start);    // Storage costs    const storage = this.calculateStorageCost(cacheStats, timeRange);    // Network costs    const network = this.calculateNetworkCost(operations, timeRange);    // Compute costs    const compute = this.calculateComputeCost(operations, timeRange);    // Total costs    const totalCost = storage.memoryCost + storage.diskCost + network.ingressCost + network.egressCost + compute.cpuCost;    const total: TotalCost = {      current: totalCost,      projected: totalCost * 1.1, // 10% growth projection      trend: 0.1,      costPerGB: totalCost / (cacheStats.totalCompressedSize / (1024 * 1024 * 1024)),      costPerOperation: totalCost / (operations.length || 1)    };    // Cost projections    const projections: CostProjection[] = [      { period: '1-month', estimatedCost: totalCost * 1.1, confidence: 0.9 },      { period: '3-month', estimatedCost: totalCost * 3 * 1.15, confidence: 0.75 },      { period: '6-month', estimatedCost: totalCost * 6 * 1.20, confidence: 0.6 }    ];    // Cost optimization recommendations    const optimizations: CostOptimization[] = [];    if (storage.utilizationPercent < 50) {      optimizations.push({        category: 'Storage Optimization',        potentialSavings: storage.memoryCost * 0.3,        effort: 'low',        recommendation: 'Reduce cache size to match actual usage'      });    }    if (compute.efficiency < 0.7) {      optimizations.push({        category: 'Compute Efficiency',        potentialSavings: compute.cpuCost * 0.2,        effort: 'medium',        recommendation: 'Optimize slow operations to reduce CPU usage'      });    }    return {      timestamp: now,      timeRange,      storage,      network,      compute,      total,      projections,      optimizations    };  }  /**   * Calculate storage costs   */  private calculateStorageCost(    stats: { totalSize: number; totalEntries: number },    timeRange: { start: number; end: number }  ): StorageCost {    const sizeGB = stats.totalSize / (1024 * 1024 * 1024);    const hours = (timeRange.end - timeRange.start) / 3600000;    const maxSizeGB = 0.5; // 500MB    const memoryCostPerGBHour = 0.10;    const diskCostPerGBHour = 0.02;    return {      memoryCost: sizeGB * memoryCostPerGBHour * hours,      diskCost: sizeGB * diskCostPerGBHour * hours,      totalStorage: stats.totalSize,      utilizationPercent: (sizeGB / maxSizeGB) * 100    };  }  /**   * Calculate network costs   */  private calculateNetworkCost(    operations: any[],    timeRange: { start: number; end: number }  ): NetworkCost {    // Estimate network traffic based on operations    const avgOperationSize = 1024; // 1KB average    const totalTraffic = operations.length * avgOperationSize;    const trafficGB = totalTraffic / (1024 * 1024 * 1024);    const ingressCostPerGB = 0.02;    const egressCostPerGB = 0.05;    return {      ingressCost: trafficGB * ingressCostPerGB * 0.5, // 50% ingress      egressCost: trafficGB * egressCostPerGB * 0.5, // 50% egress      totalTraffic,      bandwidthUtilization: 0.3 // 30% of available bandwidth    };  }  /**   * Calculate compute costs   */  private calculateComputeCost(    operations: any[],    timeRange: { start: number; end: number }  ): ComputeCost {    const totalDuration = operations.reduce((sum, op) => sum + op.duration, 0);    const cpuSeconds = totalDuration / 1000;    const costPerCPUSecond = 0.00001;    const operationCost = operations.length * 0.000001;    return {      cpuCost: cpuSeconds * costPerCPUSecond,      operationCost,      totalOperations: operations.length,      efficiency: operations.filter(op => op.cacheHit).length / (operations.length || 1)    };  }  // ============================================================================  // Export Operations  // ============================================================================  /**   * Export analytics data   */  private async exportData(options: CacheAnalyticsOptions): Promise<string> {    const format = options.format || 'json';    const filePath = options.filePath || join(process.cwd(), `cache-analytics-${Date.now()}.${format}`);    const now = Date.now();    const timeRange = options.timeRange || { start: now - 86400000, end: now };    // Collect all data    const data = {      exportDate: new Date(now).toISOString(),      timeRange,      dashboard: await this.getDashboard({ ...options, timeRange }),      metrics: await this.getMetrics({ ...options, timeRange }),      trends: await this.analyzeTrends({ ...options, timeRange }),      alerts: await this.checkAlerts({ ...options, timeRange }),      bottlenecks: await this.identifyBottlenecks({ ...options, timeRange }),      costAnalysis: await this.analyzeCosts({ ...options, timeRange })    };    // Export based on format    switch (format) {      case 'json':        await this.exportJSON(data, filePath);        break;      case 'csv':        await this.exportCSV(data, filePath);        break;      case 'excel':        throw new Error('Excel export not yet implemented');      default:        throw new Error(`Unknown export format: ${format}`);    }    return filePath;  }  /**   * Export data as JSON   */  private async exportJSON(data: any, filePath: string): Promise<void> {    const stream = createWriteStream(filePath);    stream.write(JSON.stringify(data, null, 2));    stream.end();  }  /**   * Export data as CSV   */  private async exportCSV(data: any, filePath: string): Promise<void> {    const stream = createWriteStream(filePath);    // Write header    stream.write('Metric,Value,Timestamp\n');    // Write performance metrics    if (data.metrics?.performance) {      const perf = data.metrics.performance;      stream.write(`Hit Rate,${perf.hitRate},${data.exportDate}\n`);      stream.write(`P50 Latency,${perf.latencyP50},${data.exportDate}\n`);      stream.write(`P95 Latency,${perf.latencyP95},${data.exportDate}\n`);      stream.write(`P99 Latency,${perf.latencyP99},${data.exportDate}\n`);      stream.write(`Throughput,${perf.throughput},${data.exportDate}\n`);    }    stream.end();  }  // ============================================================================  // Helper Methods  // ============================================================================  /**   * Extract key from operation name   */  private extractKeyFromOperation(operation: string): string {    // Simple extraction - in practice would parse operation details    const match = operation.match(/key:([a-zA-Z0-9-]+)/);    return match ? match[1] : 'unknown';  }  /**   * Calculate fragmentation index   */  private calculateFragmentation(): number {    // Simulated fragmentation calculation    return Math.random() * 20; // 0-20% fragmentation  }}// ============================================================================// MCP Tool Definition// ============================================================================export const CACHEANALYTICSTOOL = {  name: 'cacheanalytics',  description: 'Comprehensive cache analytics with real-time dashboard, trend analysis, alerts, and cost analysis',  inputSchema: {    type: 'object',    properties: {      operation: {        type: 'string',        enum: ['dashboard', 'metrics', 'trends', 'alerts', 'heatmap', 'bottlenecks', 'cost-analysis', 'export-data'],        description: 'Analytics operation to perform'      },      timeRange: {        type: 'object',        properties: {          start: { type: 'number', description: 'Start timestamp' },          end: { type: 'number', description: 'End timestamp' }        },        description: 'Time range for analysis'      },      granularity: {        type: 'string',        enum: ['second', 'minute', 'hour', 'day'],        description: 'Data granularity'      },      metricTypes: {        type: 'array',        items: {          type: 'string',          enum: ['performance', 'usage', 'efficiency', 'cost', 'health']        },        description: 'Metric types to include'      },      aggregation: {        type: 'string',        enum: ['sum', 'avg', 'min', 'max', 'p95', 'p99'],        description: 'Aggregation method'      },      compareWith: {        type: 'string',        enum: ['previous-period', 'last-week', 'last-month'],        description: 'Comparison period'      },      trendType: {        type: 'string',        enum: ['absolute', 'percentage', 'rate'],        description: 'Trend calculation type'      },      alertType: {        type: 'string',        enum: ['threshold', 'anomaly', 'trend'],        description: 'Alert type'      },      threshold: {        type: 'number',        description: 'Alert threshold value'      },      heatmapType: {        type: 'string',        enum: ['temporal', 'key-correlation', 'memory'],        description: 'Heatmap visualization type'      },      resolution: {        type: 'string',        enum: ['low', 'medium', 'high'],        description: 'Visualization resolution'      },      format: {        type: 'string',        enum: ['json', 'csv', 'excel'],        description: 'Export format'      },      filePath: {        type: 'string',        description: 'Export file path'      },      useCache: {        type: 'boolean',        description: 'Enable caching of analytics results',        default: true      },      cacheTTL: {        type: 'number',        description: 'Cache TTL in seconds',        default: 30      }    },    required: ['operation']  }} as const;// ============================================================================// MCP Tool Runner// ============================================================================export async function runCacheAnalytics(options: CacheAnalyticsOptions): Promise<CacheAnalyticsResult> {  const cache = new CacheEngine();  const tokenCounter = new TokenCounter();  const metricsCollector = new MetricsCollector();  const tool = new CacheAnalytics(cache, tokenCounter, metricsCollector);  return await tool.run(options);}
