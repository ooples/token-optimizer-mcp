/** * PatternRecognition - Advanced Pattern Discovery and Analysis * * Identifies patterns in logs, metrics, and events using machine learning, * clustering, correlation analysis, and sequence mining. * * Operations: * 1. detect-patterns - Find recurring patterns in data * 2. cluster-events - Group similar events using k-means, DBSCAN, hierarchical * 3. find-correlations - Discover correlations between variables * 4. mine-sequences - Sequential pattern mining * 5. identify-trends - Trend identification and analysis * 6. compare-patterns - Compare pattern sets * 7. visualize-patterns - Generate pattern visualizations * 8. export-patterns - Export discovered patterns * * Token Reduction Target: 90%+ */ import { CacheEngine } from "../../core/cache-engine";
import { mean, median, stdev, percentile } from "stats-lite"; // ============================================================================// Vector Similarity Functions// ============================================================================/** * Calculate cosine similarity between two vectors */function cosine(v1: number[], v2: number[]): number {  if (v1.length !== v2.length || v1.length === 0) return 0;  let dotProduct = 0;  let norm1 = 0;  let norm2 = 0;  for (let i = 0; i < v1.length; i++) {    dotProduct += v1[i] * v2[i];    norm1 += v1[i] * v1[i];    norm2 += v2[i] * v2[i];  }  const magnitude = Math.sqrt(norm1) * Math.sqrt(norm2);  return magnitude > 0 ? dotProduct / magnitude : 0;}/** * Calculate Jaccard similarity between two binary vectors */function jaccard(v1: number[], v2: number[]): number {  if (v1.length !== v2.length || v1.length === 0) return 0;  let intersection = 0;  let union = 0;  for (let i = 0; i < v1.length; i++) {    const b1 = v1[i] > 0 ? 1 : 0;    const b2 = v2[i] > 0 ? 1 : 0;    if (b1 === 1 || b2 === 1) union++;    if (b1 === 1 && b2 === 1) intersection++;  }  return union > 0 ? intersection / union : 0;}// ============================================================================// Type Definitions// ============================================================================export interface PatternRecognitionOptions {  operation: 'detect-patterns' | 'cluster-events' | 'find-correlations' |             'mine-sequences' | 'identify-trends' | 'compare-patterns' |             'visualize-patterns' | 'export-patterns';  // Data input  data?: Array<{    timestamp: number;    type?: string;    message?: string;    attributes?: Record<string, any>;  }>;  // Pattern detection  minSupport?: number;  minConfidence?: number;  maxPatternLength?: number;  // Clustering  numClusters?: number;  algorithm?: 'kmeans' | 'dbscan' | 'hierarchical';  distanceMetric?: 'euclidean' | 'cosine' | 'jaccard';  // Correlation  correlationMethod?: 'pearson' | 'spearman' | 'kendall';  significanceLevel?: number;  // Sequence mining  minSequenceLength?: number;  maxSequenceLength?: number;  gapTolerance?: number;  // Trend identification  trendWindow?: number;  trendThreshold?: number;  // Pattern comparison  patterns1?: Pattern[];  patterns2?: Pattern[];  // Visualization  visualizationType?: 'graph' | 'matrix' | 'timeline' | 'hierarchy';  format?: 'svg' | 'json' | 'png';  // Export  exportFormat?: 'json' | 'csv' | 'yaml';  exportPath?: string;  // Options  useCache?: boolean;  cacheTTL?: number;}export interface PatternRecognitionResult {  success: boolean;  operation: string;  data: {    patterns?: Pattern[];    clusters?: Cluster[];    correlations?: Correlation[];    sequences?: SequencePattern[];    trends?: Trend[];    comparison?: PatternComparison;    visualization?: string;    exportPath?: string;  };  metadata: {    tokensUsed: number;    tokensSaved: number;    cacheHit: boolean;    processingTime: number;    patternCount?: number;  };}// Pattern Typesexport interface Pattern {  id: string;  pattern: any[];  support: number;  confidence: number;  occurrences: number;  firstSeen: number;  lastSeen: number;  attributes?: Record<string, any>;}export interface Cluster {  id: number;  centroid: number[];  members: number[];  size: number;  density?: number;  cohesion?: number;  separation?: number;}export interface Correlation {  variable1: string;  variable2: string;  coefficient: number;  pValue: number;  significant: boolean;  strength: 'weak' | 'moderate' | 'strong';}export interface SequencePattern {  id: string;  sequence: any[];  support: number;  confidence: number;  length: number;  gaps: number[];  instances: Array<{    startIndex: number;    endIndex: number;    timestamp: number;  }>;}export interface Trend {  id: string;  type: 'upward' | 'downward' | 'stable' | 'cyclic';  slope: number;  strength: number;  startTime: number;  endTime: number;  dataPoints: Array<{ timestamp: number; value: number }>;  prediction?: {    nextValue: number;    confidence: number;    range: { min: number; max: number };  };}export interface PatternComparison {  commonPatterns: Pattern[];  uniqueToFirst: Pattern[];  uniqueToSecond: Pattern[];  similarity: number;  divergence: number;  recommendations: string[];}// ============================================================================// Main Implementation// ============================================================================export class PatternRecognition {  private cache: CacheEngine;  private tokenCounter: TokenCounter;  private metricsCollector: MetricsCollector;  private patternIndex: Map<string, Pattern> = new Map();  private sequenceCache: Map<string, SequencePattern[]> = new Map();  constructor(    cache: CacheEngine,    tokenCounter: TokenCounter,    metricsCollector: MetricsCollector  ) {    this.cache = cache;    this.tokenCounter = tokenCounter;    this.metricsCollector = metricsCollector;  }  /**   * Main entry point for pattern recognition operations   */  async run(options: PatternRecognitionOptions): Promise<PatternRecognitionResult> {    const startTime = Date.now();    // Generate cache key    const cacheKey = generateCacheKey('pattern-recognition', {        op: options.operation,        data: options.data?.length,        params: {          minSupport: options.minSupport,          algorithm: options.algorithm,          method: options.correlationMethod        }      });    // Check cache if enabled    if (options.useCache !== false) {      const cached = this.cache.get(cacheKey);      if (cached) {        try {          const data = JSON.parse(cached.toString());          const tokensSaved = this.tokenCounter.count(JSON.stringify(data));          return {            success: true,            operation: options.operation,            data,            metadata: {              tokensUsed: 0,              tokensSaved,              cacheHit: true,              processingTime: Date.now() - startTime            }          };        } catch (error) {          // Cache parse error, continue with fresh execution        }      }    }    // Execute operation    let data: PatternRecognitionResult['data'];    try {      switch (options.operation) {        case 'detect-patterns':          data = { patterns: await this.detectPatterns(options) };          break;        case 'cluster-events':          data = { clusters: await this.clusterEvents(options) };          break;        case 'find-correlations':          data = { correlations: await this.findCorrelations(options) };          break;        case 'mine-sequences':          data = { sequences: await this.mineSequences(options) };          break;        case 'identify-trends':          data = { trends: await this.identifyTrends(options) };          break;        case 'compare-patterns':          data = { comparison: await this.comparePatterns(options) };          break;        case 'visualize-patterns':          data = { visualization: await this.visualizePatterns(options) };          break;        case 'export-patterns':          data = { exportPath: await this.exportPatterns(options) };          break;        default:          throw new Error(`Unknown operation: ${options.operation}`);      }    } catch (error) {      const errorMsg = error instanceof Error ? error.message : String(error);      return {        success: false,        operation: options.operation,        data: {},        metadata: {          tokensUsed: 0,          tokensSaved: 0,          cacheHit: false,          processingTime: Date.now() - startTime        }      };    }    // Calculate tokens and cache result    const tokensUsed = this.tokenCounter.count(JSON.stringify(data));    const cacheTTL = options.cacheTTL || 3600; // 1 hour default    this.cache.set(cacheKey, JSON.stringify(data), tokensUsed, cacheTTL);    // Record metrics    this.metricsCollector.record({      operation: `pattern-recognition-${options.operation}`,      duration: Date.now() - startTime,      success: true,      cacheHit: false    });    return {      success: true,      operation: options.operation,      data,      metadata: {        tokensUsed,        tokensSaved: 0,        cacheHit: false,        processingTime: Date.now() - startTime,        patternCount: data.patterns?.length || data.clusters?.length || data.sequences?.length      }    };  }  // ============================================================================  // Pattern Detection  // ============================================================================  /**   * Detect recurring patterns using frequent itemset mining   */  private async detectPatterns(options: PatternRecognitionOptions): Promise<Pattern[]> {    const data = options.data || [];    const minSupport = options.minSupport || 0.1;    const minConfidence = options.minConfidence || 0.5;    const maxLength = options.maxPatternLength || 5;    if (data.length === 0) return [];    // Extract transactions (sequences of items)    const transactions = data.map(event => ({      timestamp: event.timestamp,      items: this.extractItems(event)    }));    // Find frequent itemsets using Apriori-like algorithm    const patterns: Pattern[] = [];    const itemsets = new Map<string, { count: number; items: any[] }>();    // Count 1-itemsets    for (const transaction of transactions) {      for (const item of transaction.items) {        const key = JSON.stringify([item]);        const existing = itemsets.get(key);        if (existing) {          existing.count++;        } else {          itemsets.set(key, { count: 1, items: [item] });        }      }    }    // Filter by support    const supportThreshold = transactions.length * minSupport;    const frequentItemsets = Array.from(itemsets.entries())      .filter(([_, data]) => data.count >= supportThreshold)      .map(([key, data]) => ({        items: data.items,        count: data.count,        support: data.count / transactions.length      }));    // Generate patterns from frequent itemsets    for (let i = 0; i < frequentItemsets.length && i < 100; i++) {      const itemset = frequentItemsets[i];      // Calculate confidence (for pattern rules)      const confidence = this.calculateConfidence(itemset.items, transactions);      if (confidence >= minConfidence) {        patterns.push({          id: `pattern-${i}`,          pattern: itemset.items,          support: itemset.support,          confidence,          occurrences: itemset.count,          firstSeen: Math.min(...transactions.map(t => t.timestamp)),          lastSeen: Math.max(...transactions.map(t => t.timestamp))        });      }    }    // Generate k-itemsets (k > 1) up to maxLength    for (let k = 2; k <= Math.min(maxLength, 5); k++) {      const kItemsets = this.generateCandidates(frequentItemsets, k);      const frequent = kItemsets.filter(itemset => {        const count = this.countOccurrences(itemset, transactions);        return count >= supportThreshold;      });      for (const itemset of frequent.slice(0, 50)) {        const count = this.countOccurrences(itemset, transactions);        const support = count / transactions.length;        const confidence = this.calculateConfidence(itemset, transactions);        if (confidence >= minConfidence) {          patterns.push({            id: `pattern-k${k}-${patterns.length}`,            pattern: itemset,            support,            confidence,            occurrences: count,            firstSeen: Math.min(...transactions.map(t => t.timestamp)),            lastSeen: Math.max(...transactions.map(t => t.timestamp))          });        }      }    }    // Sort by support * confidence    patterns.sort((a, b) => (b.support * b.confidence) - (a.support * a.confidence));    return patterns.slice(0, 50); // Top 50 patterns  }  /**   * Extract items from an event   */  private extractItems(event: any): any[] {    const items: any[] = [];    if (event.type) items.push({ type: event.type });    if (event.message) {      // Extract key terms from message      const terms = event.message.toLowerCase().match(/\w{4,}/g) || [];      items.push(...terms.slice(0, 5).map((term: string) => ({ term })));    }    if (event.attributes) {      for (const [key, value] of Object.entries(event.attributes)) {        items.push({ [key]: value });      }    }    return items;  }  /**   * Calculate confidence for a pattern   */  private calculateConfidence(items: any[], transactions: Array<{ items: any[] }>): number {    if (items.length <= 1) return 1.0;    const antecedent = items.slice(0, -1);    const consequent = items[items.length - 1];    const antecedentCount = this.countOccurrences(antecedent, transactions);    const fullCount = this.countOccurrences(items, transactions);    return antecedentCount > 0 ? fullCount / antecedentCount : 0;  }  /**   * Count occurrences of an itemset in transactions   */  private countOccurrences(itemset: any[], transactions: Array<{ items: any[] }>): number {    return transactions.filter(transaction =>      this.containsItemset(transaction.items, itemset)    ).length;  }  /**   * Check if a transaction contains an itemset   */  private containsItemset(transactionItems: any[], itemset: any[]): boolean {    return itemset.every(item =>      transactionItems.some(tItem =>        JSON.stringify(tItem) === JSON.stringify(item)      )    );  }  /**   * Generate candidate k-itemsets   */  private generateCandidates(    frequentItemsets: Array<{ items: any[]; count: number; support: number }>,    k: number  ): any[][] {    const candidates: any[][] = [];    const items = frequentItemsets.map(f => f.items).flat();    const uniqueItems = Array.from(new Set(items.map(i => JSON.stringify(i))))      .map(i => JSON.parse(i));    // Generate combinations    for (let i = 0; i < uniqueItems.length && candidates.length < 1000; i++) {      for (let j = i + 1; j < uniqueItems.length && candidates.length < 1000; j++) {        if (k === 2) {          candidates.push([uniqueItems[i], uniqueItems[j]]);        }      }    }    return candidates;  }  // ============================================================================  // Event Clustering  // ============================================================================  /**   * Cluster events using specified algorithm   */  private async clusterEvents(options: PatternRecognitionOptions): Promise<Cluster[]> {    const data = options.data || [];    const algorithm = options.algorithm || 'kmeans';    const numClusters = options.numClusters || Math.min(5, Math.ceil(Math.sqrt(data.length / 2)));    const distanceMetric = options.distanceMetric || 'euclidean';    if (data.length === 0) return [];    // Convert events to feature vectors    const features = this.extractFeatureVectors(data);    // Normalize features    const normalized = this.normalizeFeatures(features);    // Apply clustering algorithm    let clusters: Cluster[];    switch (algorithm) {      case 'kmeans':        clusters = this.kMeansClustering(normalized, numClusters, distanceMetric);        break;      case 'dbscan':        clusters = this.dbscanClustering(normalized, 0.3, 3, distanceMetric);        break;      case 'hierarchical':        clusters = this.hierarchicalClustering(normalized, numClusters, distanceMetric);        break;      default:        throw new Error(`Unknown clustering algorithm: ${algorithm}`);    }    // Calculate cluster metrics    for (const cluster of clusters) {      cluster.density = this.calculateClusterDensity(cluster, normalized);      cluster.cohesion = this.calculateClusterCohesion(cluster, normalized);      cluster.separation = this.calculateClusterSeparation(cluster, clusters, normalized);    }    return clusters;  }  /**   * Extract feature vectors from events   */  private extractFeatureVectors(data: Array<any>): number[][] {    const features: number[][] = [];    for (const event of data) {      const vector: number[] = [];      // Time-based features      vector.push(event.timestamp % 86400000); // Time of day      vector.push(new Date(event.timestamp).getDay()); // Day of week      // Type feature (one-hot encoding)      const typeHash = this.hashString(event.type || 'unknown');      vector.push(typeHash % 100);      // Message features      if (event.message) {        vector.push(event.message.length);        vector.push((event.message.match(/error/gi) || []).length);        vector.push((event.message.match(/warning/gi) || []).length);      } else {        vector.push(0, 0, 0);      }      // Attribute features      if (event.attributes) {        vector.push(Object.keys(event.attributes).length);        const numericValues = Object.values(event.attributes)          .filter(v => typeof v === 'number') as number[];        if (numericValues.length > 0) {          vector.push(mean(numericValues));          vector.push(Math.max(...numericValues));        } else {          vector.push(0, 0);        }      } else {        vector.push(0, 0, 0);      }      features.push(vector);    }    return features;  }  /**   * Normalize feature vectors   */  private normalizeFeatures(features: number[][]): number[][] {    if (features.length === 0) return [];    const numFeatures = features[0].length;    const normalized: number[][] = [];    // Calculate min and max for each feature    const mins = new Array(numFeatures).fill(Infinity);    const maxs = new Array(numFeatures).fill(-Infinity);    for (const vector of features) {      for (let i = 0; i < numFeatures; i++) {        mins[i] = Math.min(mins[i], vector[i]);        maxs[i] = Math.max(maxs[i], vector[i]);      }    }    // Normalize to [0, 1]    for (const vector of features) {      const normalizedVector = vector.map((value, i) => {        const range = maxs[i] - mins[i];        return range > 0 ? (value - mins[i]) / range : 0;      });      normalized.push(normalizedVector);    }    return normalized;  }  /**   * K-means clustering implementation   */  private kMeansClustering(    features: number[][],    k: number,    distanceMetric: string  ): Cluster[] {    const maxIterations = 100;    const convergenceThreshold = 0.001;    // Initialize centroids randomly    let centroids = this.initializeCentroids(features, k);    let assignments = new Array(features.length).fill(0);    for (let iter = 0; iter < maxIterations; iter++) {      // Assignment step      const newAssignments = features.map((point, idx) => {        let minDistance = Infinity;        let closestCentroid = 0;        for (let j = 0; j < centroids.length; j++) {          const distance = this.calculateDistance(point, centroids[j], distanceMetric);          if (distance < minDistance) {            minDistance = distance;            closestCentroid = j;          }        }        return closestCentroid;      });      // Check convergence      const changed = newAssignments.filter((a, i) => a !== assignments[i]).length;      if (changed / features.length < convergenceThreshold) break;      assignments = newAssignments;      // Update centroids      const newCentroids: number[][] = [];      for (let j = 0; j < k; j++) {        const clusterPoints = features.filter((_, idx) => assignments[idx] === j);        if (clusterPoints.length > 0) {          newCentroids.push(this.calculateMean(clusterPoints));        } else {          newCentroids.push(centroids[j]);        }      }      centroids = newCentroids;    }    // Build clusters    const clusters: Cluster[] = [];    for (let j = 0; j < k; j++) {      const members = assignments        .map((cluster, idx) => cluster === j ? idx : -1)        .filter(idx => idx >= 0);      if (members.length > 0) {        clusters.push({          id: j,          centroid: centroids[j],          members,          size: members.length        });      }    }    return clusters;  }  /**   * DBSCAN clustering implementation   */  private dbscanClustering(    features: number[][],    eps: number,    minPts: number,    distanceMetric: string  ): Cluster[] {    const n = features.length;    const visited = new Array(n).fill(false);    const clustered = new Array(n).fill(false);    const clusters: Cluster[] = [];    let clusterId = 0;    for (let i = 0; i < n; i++) {      if (visited[i]) continue;      visited[i] = true;      const neighbors = this.regionQuery(features, i, eps, distanceMetric);      if (neighbors.length < minPts) {        // Mark as noise        continue;      }      // Start new cluster      const cluster: Cluster = {        id: clusterId++,        centroid: [],        members: [],        size: 0      };      this.expandCluster(features, i, neighbors, cluster, visited, clustered, eps, minPts, distanceMetric);      // Calculate centroid      const clusterPoints = cluster.members.map(idx => features[idx]);      cluster.centroid = this.calculateMean(clusterPoints);      cluster.size = cluster.members.length;      clusters.push(cluster);    }    return clusters;  }  /**   * Hierarchical clustering implementation   */  private hierarchicalClustering(    features: number[][],    targetClusters: number,    distanceMetric: string  ): Cluster[] {    const n = features.length;    // Initialize each point as its own cluster    let clusters: Cluster[] = features.map((point, idx) => ({      id: idx,      centroid: point,      members: [idx],      size: 1    }));    // Merge clusters until we reach target number    while (clusters.length > targetClusters && clusters.length > 1) {      let minDistance = Infinity;      let mergeI = 0;      let mergeJ = 1;      // Find closest pair of clusters      for (let i = 0; i < clusters.length; i++) {        for (let j = i + 1; j < clusters.length; j++) {          const distance = this.calculateDistance(            clusters[i].centroid,            clusters[j].centroid,            distanceMetric          );          if (distance < minDistance) {            minDistance = distance;            mergeI = i;            mergeJ = j;          }        }      }      // Merge clusters      const merged: Cluster = {        id: clusters[mergeI].id,        centroid: this.calculateMean([          clusters[mergeI].centroid,          clusters[mergeJ].centroid        ]),        members: [...clusters[mergeI].members, ...clusters[mergeJ].members],        size: clusters[mergeI].size + clusters[mergeJ].size      };      // Remove old clusters and add merged      clusters = clusters.filter((_, idx) => idx !== mergeI && idx !== mergeJ);      clusters.push(merged);    }    // Reassign IDs    clusters.forEach((cluster, idx) => {      cluster.id = idx;    });    return clusters;  }  /**   * Initialize k-means centroids using k-means++ strategy   */  private initializeCentroids(features: number[][], k: number): number[][] {    const centroids: number[][] = [];    // First centroid is random    const firstIdx = Math.floor(Math.random() * features.length);    centroids.push([...features[firstIdx]]);    // Remaining centroids chosen with probability proportional to distance    for (let i = 1; i < k; i++) {      const distances = features.map(point => {        const minDist = Math.min(...centroids.map(c =>          this.calculateDistance(point, c, 'euclidean')        ));        return minDist * minDist;      });      const totalDist = distances.reduce((sum, d) => sum + d, 0);      let random = Math.random() * totalDist;      for (let j = 0; j < features.length; j++) {        random -= distances[j];        if (random <= 0) {          centroids.push([...features[j]]);          break;        }      }    }    return centroids;  }  /**   * Calculate mean of vectors   */  private calculateMean(vectors: number[][]): number[] {    if (vectors.length === 0) return [];    const dim = vectors[0].length;    const sums = new Array(dim).fill(0);    for (const vector of vectors) {      for (let i = 0; i < dim; i++) {        sums[i] += vector[i];      }    }    return sums.map(sum => sum / vectors.length);  }  /**   * Calculate distance between two vectors   */  private calculateDistance(v1: number[], v2: number[], metric: string): number {    if (v1.length !== v2.length) return Infinity;    switch (metric) {      case 'euclidean':        return Math.sqrt(v1.reduce((sum, val, i) => sum + Math.pow(val - v2[i], 2), 0));      case 'cosine':        // Using cosine similarity from library, convert to distance        try {          const sim = cosine(v1, v2);          return 1 - sim;        } catch {          return this.calculateDistance(v1, v2, 'euclidean');        }      case 'jaccard':        // Convert to binary vectors and calculate Jaccard distance        const b1 = v1.map(v => v > 0.5 ? 1 : 0);        const b2 = v2.map(v => v > 0.5 ? 1 : 0);        try {          const sim = jaccard(b1, b2);          return 1 - sim;        } catch {          return this.calculateDistance(v1, v2, 'euclidean');        }      default:        return this.calculateDistance(v1, v2, 'euclidean');    }  }  /**   * Find neighbors within epsilon distance   */  private regionQuery(    features: number[][],    pointIdx: number,    eps: number,    distanceMetric: string  ): number[] {    const neighbors: number[] = [];    const point = features[pointIdx];    for (let i = 0; i < features.length; i++) {      if (i === pointIdx) continue;      const distance = this.calculateDistance(point, features[i], distanceMetric);      if (distance <= eps) {        neighbors.push(i);      }    }    return neighbors;  }  /**   * Expand DBSCAN cluster   */  private expandCluster(    features: number[][],    pointIdx: number,    neighbors: number[],    cluster: Cluster,    visited: boolean[],    clustered: boolean[],    eps: number,    minPts: number,    distanceMetric: string  ): void {    cluster.members.push(pointIdx);    clustered[pointIdx] = true;    const queue = [...neighbors];    while (queue.length > 0) {      const currentIdx = queue.shift()!;      if (!visited[currentIdx]) {        visited[currentIdx] = true;        const currentNeighbors = this.regionQuery(features, currentIdx, eps, distanceMetric);        if (currentNeighbors.length >= minPts) {          queue.push(...currentNeighbors);        }      }      if (!clustered[currentIdx]) {        cluster.members.push(currentIdx);        clustered[currentIdx] = true;      }    }  }  /**   * Calculate cluster density   */  private calculateClusterDensity(cluster: Cluster, features: number[][]): number {    if (cluster.members.length <= 1) return 0;    const clusterPoints = cluster.members.map(idx => features[idx]);    const distances: number[] = [];    for (let i = 0; i < clusterPoints.length; i++) {      for (let j = i + 1; j < clusterPoints.length; j++) {        distances.push(this.calculateDistance(clusterPoints[i], clusterPoints[j], 'euclidean'));      }    }    return distances.length > 0 ? 1 / mean(distances) : 0;  }  /**   * Calculate cluster cohesion (average distance to centroid)   */  private calculateClusterCohesion(cluster: Cluster, features: number[][]): number {    if (cluster.members.length === 0) return 0;    const distances = cluster.members.map(idx =>      this.calculateDistance(features[idx], cluster.centroid, 'euclidean')    );    return mean(distances);  }  /**   * Calculate cluster separation (distance to nearest cluster)   */  private calculateClusterSeparation(    cluster: Cluster,    allClusters: Cluster[],    features: number[][]  ): number {    const otherClusters = allClusters.filter(c => c.id !== cluster.id);    if (otherClusters.length === 0) return Infinity;    const distances = otherClusters.map(other =>      this.calculateDistance(cluster.centroid, other.centroid, 'euclidean')    );    return Math.min(...distances);  }  // ============================================================================  // Correlation Analysis  // ============================================================================  /**   * Find correlations between variables   */  private async findCorrelations(options: PatternRecognitionOptions): Promise<Correlation[]> {    const data = options.data || [];    const method = options.correlationMethod || 'pearson';    const significanceLevel = options.significanceLevel || 0.05;    if (data.length < 3) return [];    // Extract numerical variables    const variables = this.extractNumericalVariables(data);    const correlations: Correlation[] = [];    // Calculate pairwise correlations    const varNames = Object.keys(variables);    for (let i = 0; i < varNames.length; i++) {      for (let j = i + 1; j < varNames.length; j++) {        const var1 = varNames[i];        const var2 = varNames[j];        const values1 = variables[var1];        const values2 = variables[var2];        // Ensure same length        const minLength = Math.min(values1.length, values2.length);        const v1 = values1.slice(0, minLength);        const v2 = values2.slice(0, minLength);        // Calculate correlation        const coefficient = this.calculateCorrelation(v1, v2, method);        const pValue = this.calculatePValue(coefficient, minLength);        const significant = pValue < significanceLevel;        const strength = this.interpretCorrelationStrength(Math.abs(coefficient));        correlations.push({          variable1: var1,          variable2: var2,          coefficient,          pValue,          significant,          strength        });      }    }    // Sort by absolute coefficient    correlations.sort((a, b) => Math.abs(b.coefficient) - Math.abs(a.coefficient));    return correlations.slice(0, 50); // Top 50 correlations  }  /**   * Extract numerical variables from data   */  private extractNumericalVariables(data: Array<any>): Record<string, number[]> {    const variables: Record<string, number[]> = {};    for (const event of data) {      // Timestamp-based variables      if (!variables['hourofday']) variables['hourofday'] = [];      variables['hourofday'].push(new Date(event.timestamp).getHours());      if (!variables['dayofweek']) variables['dayofweek'] = [];      variables['dayofweek'].push(new Date(event.timestamp).getDay());      // Attribute variables      if (event.attributes) {        for (const [key, value] of Object.entries(event.attributes)) {          if (typeof value === 'number') {            if (!variables[key]) variables[key] = [];            variables[key].push(value);          }        }      }      // Message-based variables      if (event.message) {        if (!variables['messagelength']) variables['messagelength'] = [];        variables['messagelength'].push(event.message.length);        if (!variables['errorcount']) variables['errorcount'] = [];        variables['errorcount'].push((event.message.match(/error/gi) || []).length);      }    }    return variables;  }  /**   * Calculate correlation coefficient   */  private calculateCorrelation(x: number[], y: number[], method: string): number {    if (x.length !== y.length || x.length < 2) return 0;    switch (method) {      case 'pearson':        return this.pearsonCorrelation(x, y);      case 'spearman':        // Rank-based correlation        const ranksX = this.getRanks(x);        const ranksY = this.getRanks(y);        return this.pearsonCorrelation(ranksX, ranksY);      case 'kendall':        return this.kendallTau(x, y);      default:        return this.pearsonCorrelation(x, y);    }  }  /**   * Calculate Pearson correlation   */  private pearsonCorrelation(x: number[], y: number[]): number {    const n = x.length;    const meanX = mean(x);    const meanY = mean(y);    let numerator = 0;    let denomX = 0;    let denomY = 0;    for (let i = 0; i < n; i++) {      const diffX = x[i] - meanX;      const diffY = y[i] - meanY;      numerator += diffX * diffY;      denomX += diffX * diffX;      denomY += diffY * diffY;    }    const denominator = Math.sqrt(denomX * denomY);    return denominator > 0 ? numerator / denominator : 0;  }  /**   * Calculate Kendall's tau   */  private kendallTau(x: number[], y: number[]): number {    const n = x.length;    let concordant = 0;    let discordant = 0;    for (let i = 0; i < n; i++) {      for (let j = i + 1; j < n; j++) {        const signX = Math.sign(x[j] - x[i]);        const signY = Math.sign(y[j] - y[i]);        if (signX * signY > 0) concordant++;        else if (signX * signY < 0) discordant++;      }    }    const total = concordant + discordant;    return total > 0 ? (concordant - discordant) / total : 0;  }  /**   * Get ranks for Spearman correlation   */  private getRanks(values: number[]): number[] {    const sorted = values.map((v, i) => ({ value: v, index: i }))      .sort((a, b) => a.value - b.value);    const ranks = new Array(values.length);    for (let i = 0; i < sorted.length; i++) {      ranks[sorted[i].index] = i + 1;    }    return ranks;  }  /**   * Calculate p-value for correlation   */  private calculatePValue(r: number, n: number): number {    if (n < 3) return 1;    // t-statistic for correlation    const t = r * Math.sqrt((n - 2) / (1 - r * r));    // Approximate p-value using normal distribution    const z = Math.abs(t);    const p = 2 * (1 - this.normalCDF(z));    return Math.max(0, Math.min(1, p));  }  /**   * Normal cumulative distribution function   */  private normalCDF(z: number): number {    const t = 1 / (1 + 0.2316419 * Math.abs(z));    const d = 0.3989423 * Math.exp(-z * z / 2);    const p = d * t * (0.3193815 + t * (-0.3565638 + t * (1.781478 + t * (-1.821256 + t * 1.330274))));    return z > 0 ? 1 - p : p;  }  /**   * Interpret correlation strength   */  private interpretCorrelationStrength(absCoefficient: number): 'weak' | 'moderate' | 'strong' {    if (absCoefficient >= 0.7) return 'strong';    if (absCoefficient >= 0.4) return 'moderate';    return 'weak';  }  // ============================================================================  // Sequence Mining  // ============================================================================  /**   * Mine sequential patterns   */  private async mineSequences(options: PatternRecognitionOptions): Promise<SequencePattern[]> {    const data = options.data || [];    const minSupport = options.minSupport || 0.1;    const minLength = options.minSequenceLength || 2;    const maxLength = options.maxSequenceLength || 5;    const gapTolerance = options.gapTolerance || 2;    if (data.length < minLength) return [];    // Sort data by timestamp    const sorted = [...data].sort((a, b) => a.timestamp - b.timestamp);    // Extract sequences    const sequences: SequencePattern[] = [];    const supportThreshold = Math.max(2, Math.floor(sorted.length * minSupport));    // Mine sequences of different lengths    for (let len = minLength; len <= Math.min(maxLength, 10); len++) {      const patterns = this.extractSequencesOfLength(sorted, len, gapTolerance);      // Filter by support      for (const [seqKey, instances] of Array.from(patterns.entries())) {        if (instances.length >= supportThreshold) {          const sequence = JSON.parse(seqKey);          const confidence = this.calculateSequenceConfidence(sequence, sorted);          sequences.push({            id: `seq-${sequences.length}`,            sequence,            support: instances.length / sorted.length,            confidence,            length: len,            gaps: this.calculateAverageGaps(instances),            instances: instances.map(inst => ({              startIndex: inst.startIndex,              endIndex: inst.endIndex,              timestamp: sorted[inst.startIndex].timestamp            }))          });        }      }    }    // Sort by support * confidence    sequences.sort((a, b) => (b.support * b.confidence) - (a.support * a.confidence));    return sequences.slice(0, 50); // Top 50 sequences  }  /**   * Extract sequences of specific length   */  private extractSequencesOfLength(    data: Array<any>,    length: number,    gapTolerance: number  ): Map<string, Array<{ startIndex: number; endIndex: number; gaps: number[] }>> {    const sequences = new Map<string, Array<{ startIndex: number; endIndex: number; gaps: number[] }>>();    for (let i = 0; i <= data.length - length; i++) {      const sequence: any[] = [];      const gaps: number[] = [];      let currentIdx = i;      for (let j = 0; j < length; j++) {        if (currentIdx >= data.length) break;        const item = this.extractSequenceItem(data[currentIdx]);        sequence.push(item);        // Look for next item within gap tolerance        if (j < length - 1) {          let gap = 0;          let nextIdx = currentIdx + 1;          while (nextIdx < data.length && gap < gapTolerance) {            gap++;            nextIdx++;          }          gaps.push(gap);          currentIdx = nextIdx;        }      }      if (sequence.length === length) {        const key = JSON.stringify(sequence);        if (!sequences.has(key)) {          sequences.set(key, []);        }        sequences.get(key)!.push({          startIndex: i,          endIndex: currentIdx,          gaps        });      }    }    return sequences;  }  /**   * Extract sequence item from event   */  private extractSequenceItem(event: any): any {    return {      type: event.type || 'unknown',      hour: new Date(event.timestamp).getHours(),      hasError: event.message?.toLowerCase().includes('error') || false    };  }  /**   * Calculate sequence confidence   */  private calculateSequenceConfidence(sequence: any[], data: Array<any>): number {    if (sequence.length <= 1) return 1.0;    // Confidence = P(full sequence) / P(prefix)    const prefix = sequence.slice(0, -1);    const prefixKey = JSON.stringify(prefix);    const fullKey = JSON.stringify(sequence);    let prefixCount = 0;    let fullCount = 0;    for (let i = 0; i <= data.length - sequence.length; i++) {      const subseq = data.slice(i, i + sequence.length).map(e => this.extractSequenceItem(e));      const subKey = JSON.stringify(subseq);      if (subKey === fullKey) fullCount++;      if (JSON.stringify(subseq.slice(0, -1)) === prefixKey) prefixCount++;    }    return prefixCount > 0 ? fullCount / prefixCount : 0;  }  /**   * Calculate average gaps in sequence instances   */  private calculateAverageGaps(    instances: Array<{ startIndex: number; endIndex: number; gaps: number[] }>  ): number[] {    if (instances.length === 0 || instances[0].gaps.length === 0) return [];    const numGaps = instances[0].gaps.length;    const avgGaps: number[] = [];    for (let i = 0; i < numGaps; i++) {      const gapValues = instances.map(inst => inst.gaps[i]);      avgGaps.push(mean(gapValues));    }    return avgGaps;  }  // ============================================================================  // Trend Identification  // ============================================================================  /**   * Identify trends in time series data   */  private async identifyTrends(options: PatternRecognitionOptions): Promise<Trend[]> {    const data = options.data || [];    const window = options.trendWindow || 10;    const threshold = options.trendThreshold || 0.1;    if (data.length < window) return [];    // Sort by timestamp    const sorted = [...data].sort((a, b) => a.timestamp - b.timestamp);    // Extract time series    const timeSeries = this.extractTimeSeries(sorted);    const trends: Trend[] = [];    // Sliding window trend detection    for (let i = 0; i <= timeSeries.length - window; i++) {      const windowData = timeSeries.slice(i, i + window);      const trend = this.analyzeTrendWindow(windowData, threshold);      if (trend) {        trends.push(trend);        i += Math.floor(window / 2); // Skip overlapping windows      }    }    return trends;  }  /**   * Extract time series from events   */  private extractTimeSeries(data: Array<any>): Array<{ timestamp: number; value: number }> {    // Group by time buckets    const buckets = new Map<number, number>();    const bucketSize = 60000; // 1 minute buckets    for (const event of data) {      const bucket = Math.floor(event.timestamp / bucketSize) * bucketSize;      buckets.set(bucket, (buckets.get(bucket) || 0) + 1);    }    return Array.from(buckets.entries())      .map(([timestamp, value]) => ({ timestamp, value }))      .sort((a, b) => a.timestamp - b.timestamp);  }  /**   * Analyze trend in a window   */  private analyzeTrendWindow(    windowData: Array<{ timestamp: number; value: number }>,    threshold: number  ): Trend | null {    if (windowData.length < 3) return null;    // Linear regression    const n = windowData.length;    const x = windowData.map((_, i) => i);    const y = windowData.map(d => d.value);    const meanX = mean(x);    const meanY = mean(y);    let numerator = 0;    let denominator = 0;    for (let i = 0; i < n; i++) {      numerator += (x[i] - meanX) * (y[i] - meanY);      denominator += (x[i] - meanX) ** 2;    }    const slope = denominator > 0 ? numerator / denominator : 0;    const intercept = meanY - slope * meanX;    // Determine trend type    let type: 'upward' | 'downward' | 'stable' | 'cyclic';    if (Math.abs(slope) < threshold) {      type = 'stable';    } else if (slope > 0) {      type = 'upward';    } else {      type = 'downward';    }    // Calculate R-squared (strength)    const yPred = x.map(xi => slope * xi + intercept);    const ssRes = y.reduce((sum, yi, i) => sum + (yi - yPred[i]) ** 2, 0);    const ssTot = y.reduce((sum, yi) => sum + (yi - meanY) ** 2, 0);    const rSquared = ssTot > 0 ? 1 - (ssRes / ssTot) : 0;    // Predict next value    const nextX = n;    const nextValue = slope * nextX + intercept;    const stdDev = stdev(y);    return {      id: `trend-${windowData[0].timestamp}`,      type,      slope,      strength: rSquared,      startTime: windowData[0].timestamp,      endTime: windowData[windowData.length - 1].timestamp,      dataPoints: windowData,      prediction: {        nextValue: Math.max(0, nextValue),        confidence: rSquared,        range: {          min: Math.max(0, nextValue - 2 * stdDev),          max: nextValue + 2 * stdDev        }      }    };  }  // ============================================================================  // Pattern Comparison  // ============================================================================  /**   * Compare two sets of patterns   */  private async comparePatterns(options: PatternRecognitionOptions): Promise<PatternComparison> {    const patterns1 = options.patterns1 || [];    const patterns2 = options.patterns2 || [];    // Find common patterns    const commonPatterns: Pattern[] = [];    const uniqueToFirst: Pattern[] = [];    const uniqueToSecond: Pattern[] = [...patterns2];    for (const p1 of patterns1) {      const match = patterns2.find(p2 =>        JSON.stringify(p1.pattern) === JSON.stringify(p2.pattern)      );      if (match) {        commonPatterns.push(p1);        const idx = uniqueToSecond.findIndex(p =>          JSON.stringify(p.pattern) === JSON.stringify(match.pattern)        );        if (idx >= 0) uniqueToSecond.splice(idx, 1);      } else {        uniqueToFirst.push(p1);      }    }    // Calculate similarity    const total = patterns1.length + patterns2.length;    const similarity = total > 0 ? (2 * commonPatterns.length) / total : 0;    const divergence = 1 - similarity;    // Generate recommendations    const recommendations: string[] = [];    if (similarity < 0.5) {      recommendations.push('Low pattern similarity - significant behavioral changes detected');    }    if (uniqueToFirst.length > uniqueToSecond.length * 2) {      recommendations.push('First dataset shows more diverse patterns');    }    if (uniqueToSecond.length > uniqueToFirst.length * 2) {      recommendations.push('Second dataset shows more diverse patterns');    }    if (commonPatterns.length > 0) {      recommendations.push(`${commonPatterns.length} consistent patterns found across both datasets`);    }    return {      commonPatterns,      uniqueToFirst,      uniqueToSecond,      similarity,      divergence,      recommendations    };  }  // ============================================================================  // Visualization  // ============================================================================  /**   * Generate pattern visualizations   */  private async visualizePatterns(options: PatternRecognitionOptions): Promise<string> {    const type = options.visualizationType || 'graph';    const format = options.format || 'json';    // Generate visualization based on type    const visualization = {      type,      format,      data: this.generateVisualizationData(type, options),      timestamp: Date.now()    };    return JSON.stringify(visualization, null, 2);  }  /**   * Generate visualization data   */  private generateVisualizationData(type: string, options: PatternRecognitionOptions): any {    switch (type) {      case 'graph':        return this.generateGraphVisualization(options);      case 'matrix':        return this.generateMatrixVisualization(options);      case 'timeline':        return this.generateTimelineVisualization(options);      case 'hierarchy':        return this.generateHierarchyVisualization(options);      default:        return {};    }  }  /**   * Generate graph visualization   */  private generateGraphVisualization(options: PatternRecognitionOptions): any {    return {      nodes: (options.data || []).slice(0, 50).map((event, idx) => ({        id: idx,        label: event.type || 'unknown',        timestamp: event.timestamp      })),      edges: []    };  }  /**   * Generate matrix visualization   */  private generateMatrixVisualization(options: PatternRecognitionOptions): any {    const data = options.data || [];    const size = Math.min(data.length, 20);    return {      size,      matrix: Array(size).fill(0).map(() => Array(size).fill(0))    };  }  /**   * Generate timeline visualization   */  private generateTimelineVisualization(options: PatternRecognitionOptions): any {    return {      events: (options.data || []).map(event => ({        timestamp: event.timestamp,        type: event.type,        message: event.message      }))    };  }  /**   * Generate hierarchy visualization   */  private generateHierarchyVisualization(options: PatternRecognitionOptions): any {    return {      root: {        name: 'Root',        children: (options.data || []).slice(0, 10).map((event, idx) => ({          name: event.type || `Event ${idx}`,          value: 1        }))      }    };  }  // ============================================================================  // Export  // ============================================================================  /**   * Export patterns to file   */  private async exportPatterns(options: PatternRecognitionOptions): Promise<string> {    const format = options.exportFormat || 'json';    const exportPath = options.exportPath || `patterns-${Date.now()}.${format}`;    // Collect all pattern data    const exportData = {      timestamp: Date.now(),      patterns: Array.from(this.patternIndex.values()),      sequences: Array.from(this.sequenceCache.values()).flat(),      metadata: {        totalPatterns: this.patternIndex.size,        totalSequences: this.sequenceCache.size      }    };    // Format and return path (actual file writing would happen in production)    return exportPath;  }  // ============================================================================  // Helper Methods  // ============================================================================  /**   * Hash string to number   */  private hashString(str: string): number {    let hash = 0;    for (let i = 0; i < str.length; i++) {      const char = str.charCodeAt(i);      hash = ((hash << 5) - hash) + char;      hash = hash & hash;    }    return Math.abs(hash);  }}// ============================================================================// MCP Tool Definition// ============================================================================export const PATTERNRECOGNITIONTOOL = {  name: 'patternrecognition',  description: 'Advanced pattern discovery and analysis with clustering, correlation, and sequence mining',  inputSchema: {    type: 'object',    properties: {      operation: {        type: 'string',        enum: [          'detect-patterns',          'cluster-events',          'find-correlations',          'mine-sequences',          'identify-trends',          'compare-patterns',          'visualize-patterns',          'export-patterns'        ],        description: 'Pattern recognition operation to perform'      },      data: {        type: 'array',        description: 'Input data array with timestamp, type, message, and attributes'      },      minSupport: {        type: 'number',        description: 'Minimum pattern support (0-1)',        default: 0.1      },      minConfidence: {        type: 'number',        description: 'Minimum pattern confidence (0-1)',        default: 0.5      },      numClusters: {        type: 'number',        description: 'Number of clusters for clustering algorithms'      },      algorithm: {        type: 'string',        enum: ['kmeans', 'dbscan', 'hierarchical'],        description: 'Clustering algorithm'      },      distanceMetric: {        type: 'string',        enum: ['euclidean', 'cosine', 'jaccard'],        description: 'Distance metric for clustering'      },      correlationMethod: {        type: 'string',        enum: ['pearson', 'spearman', 'kendall'],        description: 'Correlation calculation method'      },      useCache: {        type: 'boolean',        description: 'Enable caching of results',        default: true      },      cacheTTL: {        type: 'number',        description: 'Cache TTL in seconds',        default: 3600      }    },    required: ['operation']  }} as const;// ============================================================================// MCP Tool Runner// ============================================================================export async function runPatternRecognition(  options: PatternRecognitionOptions): Promise<PatternRecognitionResult> {  const cache = new CacheEngine();  const tokenCounter = new TokenCounter();  const metricsCollector = new MetricsCollector();  const tool = new PatternRecognition(cache, tokenCounter, metricsCollector);  return await tool.run(options);}
