/** * AutoRemediation - Automated Problem Detection and Remediation * * Automated problem detection and remediation with safe execution, * rollback capabilities, and learning from successful fixes. * * Operations: * 1. detect-issues - Detect system issues * 2. suggest-fixes - Suggest remediation actions * 3. execute-fix - Execute remediation (with approval) * 4. rollback - Rollback failed remediation * 5. create-playbook - Create custom playbook * 6. test-fix - Test fix effectiveness * 7. learn - Learn from successful fixes * 8. get-history - Get remediation history * * Token Reduction Target: 90%+ */ import { CacheEngine } from "../../core/cache-engine";
import { TokenCounter } from "../../core/token-counter";
import { MetricsCollector } from "../../core/metrics";
import { generateCacheKey } from "../shared/hash-utils";
import { createHash, randomUUID } from "crypto"; // ============================================================================// Type Definitions// ============================================================================export interface AutoRemediationOptions {  operation: 'detect-issues' | 'suggest-fixes' | 'execute-fix' | 'rollback' |             'create-playbook' | 'test-fix' | 'learn' | 'get-history';  // Issue detection  symptoms?: {    type: 'performance' | 'availability' | 'error' | 'security';    severity: 'low' | 'medium' | 'high' | 'critical';    metrics?: Record<string, number>;    logs?: string[];    events?: Array<{ timestamp: number; type: string; message: string }>;  };  // Fix suggestion  issueId?: string;  constraints?: {    maxDowntime?: number;    requiresApproval?: boolean;    rollbackEnabled?: boolean;  };  // Fix execution  fixId?: string;  dryRun?: boolean;  approvalToken?: string;  // Playbook  playbookId?: string;  playbook?: {    name: string;    trigger: { type: string; conditions: Record<string, any> };    steps: Array<{      action: string;      parameters: Record<string, any>;      rollback?: { action: string; parameters: Record<string, any> };    }>;    validation: { metric: string; threshold: number };  };  // Learning  fixSuccess?: boolean;  outcomeMetrics?: Record<string, number>;  // History  timeRange?: { start: number; end: number };  filter?: {    severity?: string;    status?: string;    playbookId?: string;  };  // Options  useCache?: boolean;  cacheTTL?: number;}export interface AutoRemediationResult {  success: boolean;  operation: string;  data: {    issues?: Array<{      id: string;      type: string;      severity: string;      description: string;      impact: string;      confidence: number;      detectedAt: number;      metrics?: Record<string, number>;    }>;    fixes?: Array<{      id: string;      description: string;      steps: string[];      riskLevel: 'low' | 'medium' | 'high';      estimatedTime: number;      requiresApproval: boolean;      rollbackAvailable: boolean;      confidence: number;      expectedOutcome: string;    }>;    execution?: {      fixId: string;      status: 'success' | 'failed' | 'partial' | 'pending';      stepsCompleted: number;      stepsTotal: number;      logs: string[];      rollbackId?: string;      startedAt: number;      completedAt?: number;      error?: string;    };    playbooks?: Array<{      id: string;      name: string;      successRate: number;      avgExecutionTime: number;      lastUsed?: number;      timesUsed: number;    }>;    validation?: {      fixed: boolean;      metrics: Record<string, { before: number; after: number }>;      improvement: number;      confidence: number;    };    history?: RemediationHistoryEntry[];    learning?: {      patterns: Array<{        issue: string;        solution: string;        successRate: number;        confidence: number;      }>;      recommendations: string[];    };  };  metadata: {    tokensUsed: number;    tokensSaved: number;    cacheHit: boolean;    executionTime: number;    confidence: number;  };}// Supporting Typesexport interface DetectedIssue {  id: string;  type: 'performance' | 'availability' | 'error' | 'security' | 'resource' | 'configuration';  severity: 'low' | 'medium' | 'high' | 'critical';  description: string;  impact: string;  confidence: number;  detectedAt: number;  symptoms: IssueSymptom[];  relatedMetrics: Record<string, number>;  suggestedPlaybooks: string[];}export interface IssueSymptom {  type: string;  value: any;  timestamp: number;  severity: number;}export interface RemediationFix {  id: string;  issueId: string;  description: string;  steps: FixStep[];  riskLevel: 'low' | 'medium' | 'high';  estimatedTime: number;  requiresApproval: boolean;  rollbackAvailable: boolean;  confidence: number;  expectedOutcome: string;  playbookId?: string;}export interface FixStep {  order: number;  action: string;  parameters: Record<string, any>;  description: string;  rollback?: {    action: string;    parameters: Record<string, any>;    description: string;  };  validation?: {    metric: string;    expectedValue: any;    condition: 'gt' | 'lt' | 'eq' | 'ne';  };}export interface RemediationPlaybook {  id: string;  name: string;  version: string;  description: string;  trigger: PlaybookTrigger;  steps: FixStep[];  validation: PlaybookValidation;  metadata: {    createdAt: number;    updatedAt: number;    createdBy: string;    successRate: number;    timesUsed: number;    avgExecutionTime: number;    lastUsed?: number;  };  tags: string[];}export interface PlaybookTrigger {  type: 'manual' | 'automatic' | 'scheduled';  conditions: Record<string, any>;  priority: number;}export interface PlaybookValidation {  metric: string;  threshold: number;  condition: 'gt' | 'lt' | 'eq' | 'ne';  timeout: number;}export interface ExecutionContext {  fixId: string;  issueId: string;  playbookId?: string;  status: 'pending' | 'running' | 'success' | 'failed' | 'partial' | 'rolled-back';  currentStep: number;  totalSteps: number;  logs: ExecutionLog[];  rollbackId?: string;  startedAt: number;  completedAt?: number;  approvedBy?: string;  dryRun: boolean;  checkpoints: Map<number, StateCheckpoint>;}export interface ExecutionLog {  timestamp: number;  level: 'info' | 'warning' | 'error' | 'debug';  message: string;  step?: number;  metadata?: Record<string, any>;}export interface StateCheckpoint {  step: number;  timestamp: number;  state: Record<string, any>;  metrics: Record<string, number>;}export interface RemediationHistoryEntry {  id: string;  issueId: string;  fixId: string;  playbookId?: string;  status: 'success' | 'failed' | 'partial' | 'rolled-back';  startedAt: number;  completedAt?: number;  duration: number;  stepsCompleted: number;  stepsTotal: number;  metrics: {    before: Record<string, number>;    after: Record<string, number>;    improvement: number;  };  error?: string;  learnings: string[];}export interface LearningPattern {  id: string;  issueType: string;  symptoms: string[];  solution: string;  successRate: number;  confidence: number;  sampleSize: number;  lastUpdated: number;  playbookIds: string[];}// ============================================================================// Main Implementation// ============================================================================export class AutoRemediation {  private cache: CacheEngine;  private tokenCounter: TokenCounter;  private metricsCollector: MetricsCollector;  // In-memory storage (would use database in production)  private playbooks: Map<string, RemediationPlaybook> = new Map();  private executionContexts: Map<string, ExecutionContext> = new Map();  private history: RemediationHistoryEntry[] = [];  private learningPatterns: Map<string, LearningPattern> = new Map();  private detectedIssues: Map<string, DetectedIssue> = new Map();  constructor(    cache: CacheEngine,    tokenCounter: TokenCounter,    metricsCollector: MetricsCollector  ) {    this.cache = cache;    this.tokenCounter = tokenCounter;    this.metricsCollector = metricsCollector;    this.initializeDefaultPlaybooks();    this.initializeLearningPatterns();  }  /**   * Initialize default remediation playbooks   */  private initializeDefaultPlaybooks(): void {    // High CPU Usage Playbook    this.playbooks.set('high-cpu-remediation', {      id: 'high-cpu-remediation',      name: 'High CPU Usage Remediation',      version: '1.0.0',      description: 'Remediate high CPU usage issues',      trigger: {        type: 'automatic',        conditions: { metric: 'cpuusage', threshold: 80, condition: 'gt' },        priority: 8      },      steps: [        {          order: 1,          action: 'identify-top-processes',          parameters: { limit: 5 },          description: 'Identify top CPU-consuming processes',          validation: {            metric: 'processesidentified',            expectedValue: true,            condition: 'eq'          }        },        {          order: 2,          action: 'analyze-process-patterns',          parameters: { lookback: 3600 },          description: 'Analyze process behavior patterns',          rollback: {            action: 'restore-monitoring',            parameters: {},            description: 'Restore normal monitoring'          }        },        {          order: 3,          action: 'scale-resources',          parameters: { type: 'cpu', increment: 0.2 },          description: 'Scale CPU resources if needed',          rollback: {            action: 'scale-down-resources',            parameters: { type: 'cpu', decrement: 0.2 },            description: 'Revert resource scaling'          },          validation: {            metric: 'cpuusage',            expectedValue: 70,            condition: 'lt'          }        }      ],      validation: {        metric: 'cpuusage',        threshold: 70,        condition: 'lt',        timeout: 300      },      metadata: {        createdAt: Date.now(),        updatedAt: Date.now(),        createdBy: 'system',        successRate: 0.85,        timesUsed: 0,        avgExecutionTime: 120      },      tags: ['performance', 'cpu', 'auto-scaling']    });    // Memory Leak Playbook    this.playbooks.set('memory-leak-remediation', {      id: 'memory-leak-remediation',      name: 'Memory Leak Detection and Remediation',      version: '1.0.0',      description: 'Detect and remediate memory leaks',      trigger: {        type: 'automatic',        conditions: { metric: 'memorytrend', threshold: 0.1, condition: 'gt' },        priority: 9      },      steps: [        {          order: 1,          action: 'capture-heap-snapshot',          parameters: { format: 'json' },          description: 'Capture heap snapshot for analysis'        },        {          order: 2,          action: 'analyze-memory-growth',          parameters: { window: 1800 },          description: 'Analyze memory growth patterns',          validation: {            metric: 'leakdetected',            expectedValue: true,            condition: 'eq'          }        },        {          order: 3,          action: 'restart-service',          parameters: { graceful: true, timeout: 30 },          description: 'Gracefully restart affected service',          rollback: {            action: 'restore-service',            parameters: { snapshot: 'pre-restart' },            description: 'Restore service to previous state'          }        }      ],      validation: {        metric: 'memoryusage',        threshold: 80,        condition: 'lt',        timeout: 120      },      metadata: {        createdAt: Date.now(),        updatedAt: Date.now(),        createdBy: 'system',        successRate: 0.92,        timesUsed: 0,        avgExecutionTime: 90      },      tags: ['performance', 'memory', 'leak-detection']    });    // Database Connection Pool Exhaustion    this.playbooks.set('db-pool-remediation', {      id: 'db-pool-remediation',      name: 'Database Connection Pool Remediation',      version: '1.0.0',      description: 'Remediate database connection pool exhaustion',      trigger: {        type: 'automatic',        conditions: { metric: 'dbpoolusage', threshold: 90, condition: 'gt' },        priority: 10      },      steps: [        {          order: 1,          action: 'kill-idle-connections',          parameters: { idletimeout: 300 },          description: 'Terminate idle database connections',          rollback: {            action: 'restore-connections',            parameters: {},            description: 'Restore connection pool'          }        },        {          order: 2,          action: 'increase-pool-size',          parameters: { increment: 10 },          description: 'Increase connection pool size',          rollback: {            action: 'decrease-pool-size',            parameters: { decrement: 10 },            description: 'Restore original pool size'          },          validation: {            metric: 'dbpoolavailable',            expectedValue: 10,            condition: 'gt'          }        }      ],      validation: {        metric: 'dbpoolusage',        threshold: 70,        condition: 'lt',        timeout: 60      },      metadata: {        createdAt: Date.now(),        updatedAt: Date.now(),        createdBy: 'system',        successRate: 0.88,        timesUsed: 0,        avgExecutionTime: 45      },      tags: ['database', 'connection-pool', 'availability']    });    // API Rate Limit Exceeded    this.playbooks.set('rate-limit-remediation', {      id: 'rate-limit-remediation',      name: 'API Rate Limit Remediation',      version: '1.0.0',      description: 'Handle API rate limit exhaustion',      trigger: {        type: 'automatic',        conditions: { metric: 'ratelimitusage', threshold: 95, condition: 'gt' },        priority: 7      },      steps: [        {          order: 1,          action: 'enable-request-queuing',          parameters: { queuesize: 1000, timeout: 60 },          description: 'Enable request queuing to throttle traffic',          rollback: {            action: 'disable-request-queuing',            parameters: {},            description: 'Disable request queuing'          }        },        {          order: 2,          action: 'activate-cache-layer',          parameters: { ttl: 300, cacherate: 0.8 },          description: 'Activate aggressive caching',          rollback: {            action: 'deactivate-cache-layer',            parameters: {},            description: 'Restore normal caching'          },          validation: {            metric: 'cachehitrate',            expectedValue: 0.7,            condition: 'gt'          }        }      ],      validation: {        metric: 'ratelimitusage',        threshold: 80,        condition: 'lt',        timeout: 180      },      metadata: {        createdAt: Date.now(),        updatedAt: Date.now(),        createdBy: 'system',        successRate: 0.90,        timesUsed: 0,        avgExecutionTime: 60      },      tags: ['api', 'rate-limiting', 'availability']    });    // Disk Space Exhaustion    this.playbooks.set('disk-space-remediation', {      id: 'disk-space-remediation',      name: 'Disk Space Remediation',      version: '1.0.0',      description: 'Remediate disk space exhaustion',      trigger: {        type: 'automatic',        conditions: { metric: 'diskusage', threshold: 85, condition: 'gt' },        priority: 9      },      steps: [        {          order: 1,          action: 'cleanup-temp-files',          parameters: { agedays: 7 },          description: 'Clean up temporary files older than 7 days'        },        {          order: 2,          action: 'rotate-logs',          parameters: { compress: true, keepdays: 14 },          description: 'Rotate and compress log files',          validation: {            metric: 'diskfreed',            expectedValue: 1073741824,            condition: 'gt'          }        },        {          order: 3,          action: 'expand-volume',          parameters: { incrementgb: 10 },          description: 'Expand disk volume if available',          rollback: {            action: 'shrink-volume',            parameters: { decrementgb: 10 },            description: 'Revert volume expansion'          }        }      ],      validation: {        metric: 'diskusage',        threshold: 75,        condition: 'lt',        timeout: 300      },      metadata: {        createdAt: Date.now(),        updatedAt: Date.now(),        createdBy: 'system',        successRate: 0.87,        timesUsed: 0,        avgExecutionTime: 180      },      tags: ['storage', 'disk-space', 'resource-management']    });  }  /**   * Initialize learning patterns from historical data   */  private initializeLearningPatterns(): void {    this.learningPatterns.set('cpu-spike-pattern', {      id: 'cpu-spike-pattern',      issueType: 'performance',      symptoms: ['cpuusage > 80', 'responsetime > 1000', 'errorrate < 5'],      solution: 'Scale CPU resources and optimize top processes',      successRate: 0.85,      confidence: 0.90,      sampleSize: 50,      lastUpdated: Date.now(),      playbookIds: ['high-cpu-remediation']    });    this.learningPatterns.set('memory-leak-pattern', {      id: 'memory-leak-pattern',      issueType: 'performance',      symptoms: ['memorygrowthrate > 0.1', 'gcfrequency > 10', 'heapsize increasing'],      solution: 'Capture heap snapshot and restart service',      successRate: 0.92,      confidence: 0.95,      sampleSize: 30,      lastUpdated: Date.now(),      playbookIds: ['memory-leak-remediation']    });    this.learningPatterns.set('db-connection-pattern', {      id: 'db-connection-pattern',      issueType: 'availability',      symptoms: ['dbpoolusage > 90', 'connectionerrors > 10', 'querytimeouts increasing'],      solution: 'Kill idle connections and increase pool size',      successRate: 0.88,      confidence: 0.92,      sampleSize: 40,      lastUpdated: Date.now(),      playbookIds: ['db-pool-remediation']    });  }  /**   * Main entry point for auto-remediation operations   */  async run(options: AutoRemediationOptions): Promise<AutoRemediationResult> {    const startTime = Date.now();    // Generate cache key    const cacheKey = generateCacheKey('auto-remediation', {        op: options.operation,        id: options.issueId || options.fixId || options.playbookId,        time: options.timeRange?.start      });    // Check cache if enabled (except for execute and rollback operations)    if (options.useCache !== false &&        !['execute-fix', 'rollback'].includes(options.operation)) {      const cached = this.cache.get(cacheKey);      if (cached) {        try {          const data = JSON.parse(cached);          const tokensSaved = this.tokenCounter.count(JSON.stringify(data)).tokens;          this.metricsCollector.record({            operation: `remediation:${options.operation}`,            duration: Date.now() - startTime,            success: true,            cacheHit: true          });          return {            success: true,            operation: options.operation,            data,            metadata: {              tokensUsed: 0,              tokensSaved,              cacheHit: true,              executionTime: Date.now() - startTime,              confidence: data.fixes?.[0]?.confidence || 0.8            }          };        } catch (error) {          // Cache parse error, continue with fresh execution        }      }    }    // Execute operation    let data: AutoRemediationResult['data'];    let confidence = 0.8;    try {      switch (options.operation) {        case 'detect-issues':          const detectedIssues = await this.detectIssues(options);          data = { issues: detectedIssues.map(issue => ({            id: issue.id,            type: issue.type,            severity: issue.severity,            description: issue.description,            impact: issue.impact,            confidence: issue.confidence,            detectedAt: issue.detectedAt,            metrics: issue.relatedMetrics          })) };          confidence = this.calculateDetectionConfidence(detectedIssues);          break;        case 'suggest-fixes':          const fixes = await this.suggestFixes(options);          data = { fixes: fixes.map(fix => ({            id: fix.id,            description: fix.description,            steps: fix.steps.map(s => s.description),            riskLevel: fix.riskLevel,            estimatedTime: fix.estimatedTime,            requiresApproval: fix.requiresApproval,            rollbackAvailable: fix.rollbackAvailable,            confidence: fix.confidence,            expectedOutcome: fix.expectedOutcome          })) };          confidence = data.fixes?.[0]?.confidence || 0.8;          break;        case 'execute-fix':          const execContext = await this.executeFix(options);          data = { execution: {            fixId: execContext.fixId,            status: execContext.status === 'success' ? 'success' :                    execContext.status === 'failed' ? 'failed' :                    execContext.status === 'partial' ? 'partial' : 'pending',            stepsCompleted: execContext.currentStep,            stepsTotal: execContext.totalSteps,            logs: execContext.logs.map(l => l.message),            rollbackId: execContext.rollbackId,            startedAt: execContext.startedAt,            completedAt: execContext.completedAt          } };          confidence = 0.95;          break;        case 'rollback':          const rollbackContext = await this.rollbackFix(options);          data = { execution: {            fixId: rollbackContext.fixId,            status: rollbackContext.status === 'rolled-back' ? 'success' : 'failed',            stepsCompleted: rollbackContext.currentStep,            stepsTotal: rollbackContext.totalSteps,            logs: rollbackContext.logs.map(l => l.message),            rollbackId: rollbackContext.rollbackId,            startedAt: rollbackContext.startedAt,            completedAt: rollbackContext.completedAt          } };          confidence = 0.95;          break;        case 'create-playbook':          const playbooks = await this.createPlaybook(options);          data = { playbooks: playbooks.map(pb => ({            id: pb.id,            name: pb.name,            successRate: pb.metadata.successRate,            avgExecutionTime: pb.metadata.avgExecutionTime,            lastUsed: pb.metadata.lastUsed,            timesUsed: pb.metadata.timesUsed          })) };          confidence = 0.9;          break;        case 'test-fix':          data = { validation: await this.testFix(options) };          confidence = data.validation?.confidence || 0.85;          break;        case 'learn':          data = { learning: await this.learnFromFix(options) };          confidence = 0.9;          break;        case 'get-history':          data = { history: await this.getHistory(options) };          confidence = 1.0;          break;        default:          throw new Error(`Unknown operation: ${options.operation}`);      }    } catch (error) {      const errorMsg = error instanceof Error ? error.message : String(error);      this.metricsCollector.record({        operation: `remediation:${options.operation}`,        duration: Date.now() - startTime,        success: false,        cacheHit: false      });      return {        success: false,        operation: options.operation,        data: { execution: {          fixId: options.fixId || 'unknown',          status: 'failed',          stepsCompleted: 0,          stepsTotal: 0,          logs: [],          startedAt: startTime,          error: errorMsg        }},        metadata: {          tokensUsed: 0,          tokensSaved: 0,          cacheHit: false,          executionTime: Date.now() - startTime,          confidence: 0        }      };    }    // Calculate tokens and cache result    const tokensUsed = this.tokenCounter.count(JSON.stringify(data)).tokens;    const cacheTTL = options.cacheTTL || this.getCacheTTLForOperation(options.operation);    const dataStr = JSON.stringify(data);    if (!['execute-fix', 'rollback'].includes(options.operation)) {      this.cache.set(cacheKey, dataStr, dataStr.length, dataStr.length);    }    // Record metrics    this.metricsCollector.record({      operation: `remediation:${options.operation}`,      duration: Date.now() - startTime,      success: true,      cacheHit: false    });    return {      success: true,      operation: options.operation,      data,      metadata: {        tokensUsed,        tokensSaved: 0,        cacheHit: false,        executionTime: Date.now() - startTime,        confidence      }    };  }  // ============================================================================  // Issue Detection Operations  // ============================================================================  /**   * Detect system issues from symptoms   */  private async detectIssues(options: AutoRemediationOptions): Promise<DetectedIssue[]> {    const issues: DetectedIssue[] = [];    const symptoms = options.symptoms;    if (!symptoms) {      return issues;    }    // Analyze symptoms and detect issues    const detectionRules = this.getDetectionRules();    for (const rule of detectionRules) {      const match = this.matchSymptoms(symptoms, rule);      if (match.matched) {        const issue: DetectedIssue = {          id: randomUUID(),          type: rule.issueType,          severity: this.calculateSeverity(symptoms, match.score),          description: rule.description,          impact: rule.impact,          confidence: match.score,          detectedAt: Date.now(),          symptoms: this.extractSymptoms(symptoms),          relatedMetrics: symptoms.metrics || {},          suggestedPlaybooks: rule.suggestedPlaybooks        };        issues.push(issue);        this.detectedIssues.set(issue.id, issue);      }    }    // Sort by severity and confidence    issues.sort((a, b) => {      const severityOrder = { critical: 4, high: 3, medium: 2, low: 1 };      const severityDiff = severityOrder[b.severity] - severityOrder[a.severity];      if (severityDiff !== 0) return severityDiff;      return b.confidence - a.confidence;    });    return issues.slice(0, 10); // Top 10 issues  }  /**   * Get detection rules   */  private getDetectionRules(): Array<{    issueType: DetectedIssue['type'];    description: string;    impact: string;    conditions: Record<string, any>;    suggestedPlaybooks: string[];  }> {    return [      {        issueType: 'performance',        description: 'High CPU usage detected',        impact: 'Degraded application performance and increased response times',        conditions: { cpuusage: { gt: 80 } },        suggestedPlaybooks: ['high-cpu-remediation']      },      {        issueType: 'performance',        description: 'Memory leak suspected',        impact: 'Gradual memory exhaustion leading to service crashes',        conditions: { memorygrowthrate: { gt: 0.1 } },        suggestedPlaybooks: ['memory-leak-remediation']      },      {        issueType: 'availability',        description: 'Database connection pool exhaustion',        impact: 'Failed database operations and service unavailability',        conditions: { dbpoolusage: { gt: 90 } },        suggestedPlaybooks: ['db-pool-remediation']      },      {        issueType: 'availability',        description: 'API rate limit approaching',        impact: 'Service throttling and request failures',        conditions: { ratelimitusage: { gt: 95 } },        suggestedPlaybooks: ['rate-limit-remediation']      },      {        issueType: 'resource',        description: 'Disk space running low',        impact: 'Service failures and data loss risk',        conditions: { diskusage: { gt: 85 } },        suggestedPlaybooks: ['disk-space-remediation']      },      {        issueType: 'error',        description: 'High error rate detected',        impact: 'Service instability and user experience degradation',        conditions: { errorrate: { gt: 5 } },        suggestedPlaybooks: []      }    ];  }  /**   * Match symptoms against detection rule   */  private matchSymptoms(    symptoms: NonNullable<AutoRemediationOptions['symptoms']>,    rule: ReturnType<typeof this.getDetectionRules>[0]  ): { matched: boolean; score: number } {    let matchCount = 0;    let totalConditions = 0;    const metrics = symptoms.metrics || {};    for (const [metric, condition] of Object.entries(rule.conditions)) {      totalConditions++;      const value = metrics[metric];      if (value !== undefined) {        const condObj = condition as { gt?: number; lt?: number; eq?: number };        if (condObj.gt !== undefined && value > condObj.gt) matchCount++;        else if (condObj.lt !== undefined && value < condObj.lt) matchCount++;        else if (condObj.eq !== undefined && value === condObj.eq) matchCount++;      }    }    const score = totalConditions > 0 ? matchCount / totalConditions : 0;    return {      matched: score >= 0.7,      score    };  }  /**   * Calculate severity from symptoms   */  private calculateSeverity(    symptoms: NonNullable<AutoRemediationOptions['symptoms']>,    confidence: number  ): DetectedIssue['severity'] {    const baseSeverity = symptoms.severity;    // Adjust based on confidence    if (confidence >= 0.9) {      return baseSeverity;    } else if (confidence >= 0.7) {      const severityMap: Record<string, DetectedIssue['severity']> = {        critical: 'high',        high: 'medium',        medium: 'low',        low: 'low'      };      return severityMap[baseSeverity] || baseSeverity;    }    return 'low';  }  /**   * Extract symptoms from raw data   */  private extractSymptoms(    symptoms: NonNullable<AutoRemediationOptions['symptoms']>  ): IssueSymptom[] {    const extracted: IssueSymptom[] = [];    const now = Date.now();    // Extract from metrics    if (symptoms.metrics) {      for (const [key, value] of Object.entries(symptoms.metrics)) {        extracted.push({          type: 'metric',          value: { name: key, value },          timestamp: now,          severity: this.calculateSymptomSeverity(key, value)        });      }    }    // Extract from logs    if (symptoms.logs) {      symptoms.logs.forEach((log, index) => {        extracted.push({          type: 'log',          value: log,          timestamp: now - (index * 1000),          severity: this.detectLogSeverity(log)        });      });    }    // Extract from events    if (symptoms.events) {      symptoms.events.forEach(event => {        extracted.push({          type: 'event',          value: event,          timestamp: event.timestamp,          severity: this.detectEventSeverity(event.type)        });      });    }    return extracted;  }  /**   * Calculate symptom severity   */  private calculateSymptomSeverity(metric: string, value: number): number {    const thresholds: Record<string, { warn: number; critical: number }> = {      cpuusage: { warn: 70, critical: 90 },      memoryusage: { warn: 75, critical: 90 },      diskusage: { warn: 80, critical: 95 },      errorrate: { warn: 3, critical: 10 },      responsetime: { warn: 1000, critical: 3000 }    };    const threshold = thresholds[metric];    if (!threshold) return 0.5;    if (value >= threshold.critical) return 1.0;    if (value >= threshold.warn) return 0.7;    return 0.3;  }  /**   * Detect log severity   */  private detectLogSeverity(log: string): number {    const lowerLog = log.toLowerCase();    if (lowerLog.includes('critical') || lowerLog.includes('fatal')) return 1.0;    if (lowerLog.includes('error')) return 0.8;    if (lowerLog.includes('warn')) return 0.6;    if (lowerLog.includes('info')) return 0.3;    return 0.2;  }  /**   * Detect event severity   */  private detectEventSeverity(eventType: string): number {    const severityMap: Record<string, number> = {      crash: 1.0,      timeout: 0.8,      error: 0.7,      warning: 0.5,      info: 0.2    };    return severityMap[eventType.toLowerCase()] || 0.5;  }  /**   * Calculate detection confidence   */  private calculateDetectionConfidence(issues: DetectedIssue[]): number {    if (issues.length === 0) return 0;    const avgConfidence = issues.reduce((sum, issue) => sum + issue.confidence, 0) / issues.length;    return avgConfidence;  }  // ============================================================================  // Fix Suggestion Operations  // ============================================================================  /**   * Suggest fixes for detected issue   */  private async suggestFixes(options: AutoRemediationOptions): Promise<RemediationFix[]> {    const fixes: RemediationFix[] = [];    if (!options.issueId) {      throw new Error('Issue ID is required for suggesting fixes');    }    const issue = this.detectedIssues.get(options.issueId);    if (!issue) {      throw new Error(`Issue not found: ${options.issueId}`);    }    // Get suggested playbooks for the issue    for (const playbookId of issue.suggestedPlaybooks) {      const playbook = this.playbooks.get(playbookId);      if (playbook) {        const fix = this.playbookToFix(issue, playbook, options.constraints);        fixes.push(fix);      }    }    // Generate ML-based suggestions from learning patterns    const mlSuggestions = this.generateMLSuggestions(issue);    fixes.push(...mlSuggestions);    // Sort by confidence and risk    fixes.sort((a, b) => {      const riskOrder = { low: 1, medium: 2, high: 3 };      const riskDiff = riskOrder[a.riskLevel] - riskOrder[b.riskLevel];      if (riskDiff !== 0) return riskDiff;      return b.confidence - a.confidence;    });    return fixes;  }  /**   * Convert playbook to fix   */  private playbookToFix(    issue: DetectedIssue,    playbook: RemediationPlaybook,    constraints?: AutoRemediationOptions['constraints']  ): RemediationFix {    const requiresApproval = constraints?.requiresApproval ??                            (playbook.steps.some(s => s.rollback) ||                             issue.severity === 'critical');    const rollbackAvailable = constraints?.rollbackEnabled ??                             playbook.steps.every(s => !s.rollback || s.rollback !== undefined);    return {      id: randomUUID(),      issueId: issue.id,      description: playbook.description,      steps: playbook.steps,      riskLevel: this.calculateRiskLevel(playbook.steps),      estimatedTime: playbook.metadata.avgExecutionTime,      requiresApproval,      rollbackAvailable,      confidence: playbook.metadata.successRate,      expectedOutcome: `Resolve ${issue.type} issue and restore ${playbook.validation.metric} to normal levels`,      playbookId: playbook.id    };  }  /**   * Generate ML-based fix suggestions   */  private generateMLSuggestions(issue: DetectedIssue): RemediationFix[] {    const suggestions: RemediationFix[] = [];    // Match against learning patterns    for (const pattern of Array.from(this.learningPatterns.values())) {      if (pattern.issueType === issue.type && pattern.confidence >= 0.7) {        suggestions.push({          id: randomUUID(),          issueId: issue.id,          description: `ML Suggestion: ${pattern.solution}`,          steps: [{            order: 1,            action: 'apply-learned-solution',            parameters: { solution: pattern.solution },            description: pattern.solution          }],          riskLevel: 'medium',          estimatedTime: 60,          requiresApproval: true,          rollbackAvailable: false,          confidence: pattern.confidence,          expectedOutcome: `Apply learned solution with ${(pattern.successRate * 100).toFixed(1)}% success rate`        });      }    }    return suggestions;  }  /**   * Calculate risk level from steps   */  private calculateRiskLevel(steps: FixStep[]): RemediationFix['riskLevel'] {    const hasRollback = steps.every(s => s.rollback);    const hasRestarts = steps.some(s => s.action.includes('restart'));    const hasScaling = steps.some(s => s.action.includes('scale'));    if (!hasRollback && (hasRestarts || hasScaling)) return 'high';    if (hasScaling || hasRestarts) return 'medium';    return 'low';  }  // ============================================================================  // Fix Execution Operations  // ============================================================================  /**   * Execute remediation fix   */  private async executeFix(options: AutoRemediationOptions): Promise<ExecutionContext> {    if (!options.fixId) {      throw new Error('Fix ID is required for execution');    }    // Check if execution already exists    let context = this.executionContexts.get(options.fixId);    if (!context) {      // Create new execution context      const fixSteps = await this.getFixSteps(options.fixId);      context = {        fixId: options.fixId,        issueId: '', // Would be linked from fix        status: 'pending',        currentStep: 0,        totalSteps: fixSteps.length,        logs: [],        startedAt: Date.now(),        dryRun: options.dryRun || false,        checkpoints: new Map()      };      this.executionContexts.set(options.fixId, context);    }    // Check approval if required    if (!options.dryRun && !options.approvalToken) {      context.logs.push({        timestamp: Date.now(),        level: 'warning',        message: 'Fix execution requires approval token'      });      return this.contextToResult(context);    }    // Execute steps    context.status = 'running';    const steps = await this.getFixSteps(options.fixId);    for (let i = context.currentStep; i < steps.length; i++) {      const step = steps[i];      context.currentStep = i;      // Create checkpoint before step      await this.createCheckpoint(context, step);      // Execute step      try {        context.logs.push({          timestamp: Date.now(),          level: 'info',          message: `Executing step ${i + 1}/${steps.length}: ${step.description}`,          step: i + 1        });        if (!options.dryRun) {          await this.executeStep(step, context);        }        // Validate step        if (step.validation) {          const valid = await this.validateStep(step, context);          if (!valid) {            throw new Error(`Step validation failed: ${step.description}`);          }        }        context.logs.push({          timestamp: Date.now(),          level: 'info',          message: `Step ${i + 1} completed successfully`,          step: i + 1        });      } catch (error) {        const errorMsg = error instanceof Error ? error.message : String(error);        context.logs.push({          timestamp: Date.now(),          level: 'error',          message: `Step ${i + 1} failed: ${errorMsg}`,          step: i + 1        });        context.status = 'failed';        context.completedAt = Date.now();        // Auto-rollback if available        if (step.rollback && !options.dryRun) {          context.rollbackId = await this.initiateRollback(context, i);        }        return this.contextToResult(context);      }    }    // All steps completed    context.status = 'success';    context.currentStep = steps.length;    context.completedAt = Date.now();    context.logs.push({      timestamp: Date.now(),      level: 'info',      message: 'All remediation steps completed successfully'    });    return this.contextToResult(context);  }  /**   * Get fix steps   */  private async getFixSteps(fixId: string): Promise<FixStep[]> {    // In production, would fetch from database    // For now, return sample steps    return [      {        order: 1,        action: 'analyze',        parameters: {},        description: 'Analyze current system state'      },      {        order: 2,        action: 'remediate',        parameters: {},        description: 'Apply remediation'      },      {        order: 3,        action: 'validate',        parameters: {},        description: 'Validate fix effectiveness'      }    ];  }  /**   * Create execution checkpoint   */  private async createCheckpoint(context: ExecutionContext, step: FixStep): Promise<void> {    const checkpoint: StateCheckpoint = {      step: step.order,      timestamp: Date.now(),      state: {        // Would capture actual system state        placeholder: 'system-state'      },      metrics: {        // Would capture actual metrics        placeholder: 0      }    };    context.checkpoints.set(step.order, checkpoint);  }  /**   * Execute single step   */  private async executeStep(step: FixStep, context: ExecutionContext): Promise<void> {    // Simulate step execution    await new Promise(resolve => setTimeout(resolve, 100));    context.logs.push({      timestamp: Date.now(),      level: 'debug',      message: `Executed action: ${step.action}`,      step: step.order,      metadata: step.parameters    });  }  /**   * Validate step execution   */  private async validateStep(step: FixStep, context: ExecutionContext): Promise<boolean> {    if (!step.validation) return true;    // Simulate validation    return Math.random() > 0.1; // 90% success rate  }  /**   * Initiate rollback   */  private async initiateRollback(context: ExecutionContext, failedStep: number): Promise<string> {    const rollbackId = randomUUID();    context.logs.push({      timestamp: Date.now(),      level: 'warning',      message: `Initiating rollback due to failure at step ${failedStep + 1}`    });    // Would execute rollback steps    return rollbackId;  }  /**   * Convert context to result   */  private contextToResult(context: ExecutionContext): ExecutionContext {    return {      fixId: context.fixId,      issueId: context.issueId,      playbookId: context.playbookId,      status: context.status,      currentStep: context.currentStep,      totalSteps: context.totalSteps,      logs: context.logs.slice(-50), // Last 50 logs      rollbackId: context.rollbackId,      startedAt: context.startedAt,      completedAt: context.completedAt,      approvedBy: context.approvedBy,      dryRun: context.dryRun,      checkpoints: context.checkpoints    };  }  // ============================================================================  // Rollback Operations  // ============================================================================  /**   * Rollback a failed fix   */  private async rollbackFix(options: AutoRemediationOptions): Promise<ExecutionContext> {    if (!options.fixId) {      throw new Error('Fix ID is required for rollback');    }    const context = this.executionContexts.get(options.fixId);    if (!context) {      throw new Error(`Execution context not found: ${options.fixId}`);    }    const rollbackId = randomUUID();    context.rollbackId = rollbackId;    context.status = 'running';    context.logs.push({      timestamp: Date.now(),      level: 'warning',      message: `Starting rollback for fix ${options.fixId}`    });    // Get steps that were completed    const steps = await this.getFixSteps(options.fixId);    const completedSteps = steps.slice(0, context.currentStep).reverse();    // Execute rollback for each completed step    for (const step of completedSteps) {      if (step.rollback) {        try {          context.logs.push({            timestamp: Date.now(),            level: 'info',            message: `Rolling back: ${step.rollback.description}`          });          if (!options.dryRun) {            await this.executeStep(step.rollback as any, context);          }        } catch (error) {          const errorMsg = error instanceof Error ? error.message : String(error);          context.logs.push({            timestamp: Date.now(),            level: 'error',            message: `Rollback failed for step: ${errorMsg}`          });        }      }    }    context.status = 'rolled-back';    context.completedAt = Date.now();    context.logs.push({      timestamp: Date.now(),      level: 'info',      message: 'Rollback completed'    });    return this.contextToResult(context);  }  // ============================================================================  // Playbook Management Operations  // ============================================================================  /**   * Create custom playbook   */  private async createPlaybook(options: AutoRemediationOptions): Promise<RemediationPlaybook[]> {    if (!options.playbook) {      throw new Error('Playbook definition is required');    }    const playbook: RemediationPlaybook = {      id: options.playbookId || randomUUID(),      name: options.playbook.name,      version: '1.0.0',      description: `Custom playbook: ${options.playbook.name}`,      trigger: options.playbook.trigger as PlaybookTrigger,      steps: options.playbook.steps.map((s, i) => ({        order: i + 1,        action: s.action,        parameters: s.parameters,        description: `Step ${i + 1}: ${s.action}`,        rollback: s.rollback ? {          action: s.rollback.action,          parameters: s.rollback.parameters,          description: `Rollback: ${s.rollback.action}`        } : undefined      })),      validation: options.playbook.validation as PlaybookValidation,      metadata: {        createdAt: Date.now(),        updatedAt: Date.now(),        createdBy: 'custom',        successRate: 0,        timesUsed: 0,        avgExecutionTime: 0      },      tags: ['custom']    };    this.playbooks.set(playbook.id, playbook);    return [playbook];  }  // ============================================================================  // Testing Operations  // ============================================================================  /**   * Test fix effectiveness   */  private async testFix(options: AutoRemediationOptions): Promise<AutoRemediationResult['data']['validation']> {    if (!options.fixId) {      throw new Error('Fix ID is required for testing');    }    const context = this.executionContexts.get(options.fixId);    if (!context) {      throw new Error(`Execution context not found: ${options.fixId}`);    }    // Get before/after metrics from checkpoints    const beforeCheckpoint = context.checkpoints.get(0);    const afterCheckpoint = context.checkpoints.get(context.currentStep);    const beforeMetrics = beforeCheckpoint?.metrics || {};    const afterMetrics = afterCheckpoint?.metrics || {};    // Calculate improvement    const metricPairs: Record<string, { before: number; after: number }> = {};    let totalImprovement = 0;    let metricCount = 0;    for (const key of Object.keys(beforeMetrics)) {      if (afterMetrics[key] !== undefined) {        metricPairs[key] = {          before: beforeMetrics[key],          after: afterMetrics[key]        };        const improvement = ((beforeMetrics[key] - afterMetrics[key]) / beforeMetrics[key]) * 100;        totalImprovement += improvement;        metricCount++;      }    }    const avgImprovement = metricCount > 0 ? totalImprovement / metricCount : 0;    const fixed = avgImprovement > 10; // At least 10% improvement    return {      fixed,      metrics: metricPairs,      improvement: avgImprovement,      confidence: context.status === 'success' ? 0.9 : 0.5    };  }  // ============================================================================  // Learning Operations  // ============================================================================  /**   * Learn from fix execution   */  private async learnFromFix(options: AutoRemediationOptions): Promise<AutoRemediationResult['data']['learning']> {    if (!options.fixId || options.fixSuccess === undefined) {      throw new Error('Fix ID and success status are required for learning');    }    const context = this.executionContexts.get(options.fixId);    if (!context) {      throw new Error(`Execution context not found: ${options.fixId}`);    }    // Create history entry    const historyEntry: RemediationHistoryEntry = {      id: randomUUID(),      issueId: context.issueId,      fixId: context.fixId,      playbookId: context.playbookId,      status: context.status === 'success' ? 'success' : 'failed',      startedAt: context.startedAt,      completedAt: context.completedAt,      duration: (context.completedAt || Date.now()) - context.startedAt,      stepsCompleted: context.currentStep,      stepsTotal: context.totalSteps,      metrics: {        before: {},        after: options.outcomeMetrics || {},        improvement: 0      },      learnings: []    };    this.history.push(historyEntry);    // Update playbook statistics    if (context.playbookId) {      const playbook = this.playbooks.get(context.playbookId);      if (playbook) {        playbook.metadata.timesUsed++;        playbook.metadata.lastUsed = Date.now();        const totalSuccesses = playbook.metadata.successRate * (playbook.metadata.timesUsed - 1);        const newSuccesses = options.fixSuccess ? totalSuccesses + 1 : totalSuccesses;        playbook.metadata.successRate = newSuccesses / playbook.metadata.timesUsed;        const totalTime = playbook.metadata.avgExecutionTime * (playbook.metadata.timesUsed - 1);        playbook.metadata.avgExecutionTime = (totalTime + historyEntry.duration) / playbook.metadata.timesUsed;      }    }    // Extract patterns    const patterns = this.extractLearningPatterns();    const recommendations = this.generateRecommendations(patterns);    return {      patterns,      recommendations    };  }  /**   * Extract learning patterns   */  private extractLearningPatterns(): Array<{    issue: string;    solution: string;    successRate: number;    confidence: number;  }> {    const patterns: Array<{      issue: string;      solution: string;      successRate: number;      confidence: number;    }> = [];    for (const pattern of Array.from(this.learningPatterns.values())) {      patterns.push({        issue: pattern.issueType,        solution: pattern.solution,        successRate: pattern.successRate,        confidence: pattern.confidence      });    }    return patterns.slice(0, 5);  }  /**   * Generate recommendations   */  private generateRecommendations(patterns: ReturnType<typeof this.extractLearningPatterns>): string[] {    const recommendations: string[] = [];    if (patterns.length > 0) {      recommendations.push(`Found ${patterns.length} successful remediation patterns`);    }    const avgSuccess = patterns.reduce((sum, p) => sum + p.successRate, 0) / (patterns.length || 1);    if (avgSuccess > 0.8) {      recommendations.push('High success rate - continue using current playbooks');    } else if (avgSuccess < 0.6) {      recommendations.push('Low success rate - consider reviewing and updating playbooks');    }    recommendations.push('Enable automatic remediation for low-risk playbooks');    recommendations.push('Review rollback procedures for high-risk operations');    return recommendations;  }  // ============================================================================  // History Operations  // ============================================================================  /**   * Get remediation history   */  private async getHistory(options: AutoRemediationOptions): Promise<RemediationHistoryEntry[]> {    let history = this.history;    // Apply time range filter    if (options.timeRange) {      history = history.filter(h =>        h.startedAt >= options.timeRange!.start &&        h.startedAt <= options.timeRange!.end      );    }    // Apply filters    if (options.filter) {      if (options.filter.severity) {        // Would filter by severity if stored      }      if (options.filter.status) {        history = history.filter(h => h.status === options.filter!.status);      }      if (options.filter.playbookId) {        history = history.filter(h => h.playbookId === options.filter!.playbookId);      }    }    // Sort by start time descending    history.sort((a, b) => b.startedAt - a.startedAt);    return history.slice(0, 50); // Last 50 entries  }  // ============================================================================  // Helper Methods  // ============================================================================  /**   * Get cache TTL for operation   */  private getCacheTTLForOperation(operation: string): number {    const ttls: Record<string, number> = {      'detect-issues': 300,      // 5 minutes      'suggest-fixes': 300,      // 5 minutes      'create-playbook': 86400,  // 24 hours      'test-fix': 3600,          // 1 hour      'learn': 1800,             // 30 minutes      'get-history': 600         // 10 minutes    };    return ttls[operation] || 300;  }}// ============================================================================// MCP Tool Definition// ============================================================================export const AUTOREMEDIATIONTOOL = {  name: 'autoremediation',  description: 'Automated problem detection and remediation with safe execution, rollback capabilities, and learning',  inputSchema: {    type: 'object',    properties: {      operation: {        type: 'string',        enum: ['detect-issues', 'suggest-fixes', 'execute-fix', 'rollback', 'create-playbook', 'test-fix', 'learn', 'get-history'],        description: 'Remediation operation to perform'      },      symptoms: {        type: 'object',        properties: {          type: {            type: 'string',            enum: ['performance', 'availability', 'error', 'security'],            description: 'Type of symptoms'          },          severity: {            type: 'string',            enum: ['low', 'medium', 'high', 'critical'],            description: 'Symptom severity'          },          metrics: {            type: 'object',            description: 'Symptom metrics'          },          logs: {            type: 'array',            items: { type: 'string' },            description: 'Related log entries'          },          events: {            type: 'array',            items: { type: 'object' },            description: 'Related events'          }        },        description: 'System symptoms for detection'      },      issueId: {        type: 'string',        description: 'Issue ID for fix suggestion'      },      fixId: {        type: 'string',        description: 'Fix ID for execution or rollback'      },      dryRun: {        type: 'boolean',        description: 'Simulate fix without actual execution',        default: false      },      approvalToken: {        type: 'string',        description: 'Approval token for fix execution'      },      playbookId: {        type: 'string',        description: 'Playbook ID'      },      playbook: {        type: 'object',        properties: {          name: { type: 'string' },          trigger: { type: 'object' },          steps: { type: 'array', items: { type: 'object' } },          validation: { type: 'object' }        },        description: 'Custom playbook definition'      },      fixSuccess: {        type: 'boolean',        description: 'Whether fix was successful (for learning)'      },      outcomeMetrics: {        type: 'object',        description: 'Outcome metrics after fix (for learning)'      },      timeRange: {        type: 'object',        properties: {          start: { type: 'number' },          end: { type: 'number' }        },        description: 'Time range for history'      },      filter: {        type: 'object',        properties: {          severity: { type: 'string' },          status: { type: 'string' },          playbookId: { type: 'string' }        },        description: 'Filters for history'      },      useCache: {        type: 'boolean',        description: 'Enable caching',        default: true      },      cacheTTL: {        type: 'number',        description: 'Cache TTL in seconds'      }    },    required: ['operation']  }} as const;// ============================================================================// MCP Tool Runner// ============================================================================export async function runAutoRemediation(options: AutoRemediationOptions): Promise<AutoRemediationResult> {  const cache = new CacheEngine();  const tokenCounter = new TokenCounter();  const metricsCollector = new MetricsCollector();  const tool = new AutoRemediation(cache, tokenCounter, metricsCollector);  return await tool.run(options);}
