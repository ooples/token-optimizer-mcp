/** * PerformanceTracker - Performance Metrics Tracking and Analysis * * Track and analyze performance metrics with trend detection, forecasting, * regression detection, and baseline calculation capabilities. * * Operations: * 1. track - Record performance metrics * 2. query - Query performance data * 3. analyze-trends - Detect performance trends * 4. forecast - Predict future performance * 5. compare - Compare performance across time periods * 6. detect-regressions - Find performance degradations * 7. get-baseline - Calculate performance baselines * 8. generate-report - Create performance report * * Token Reduction Target: 89%+ */ import { CacheEngine } from "../../core/cache-engine";
import { TokenCounter } from "../../core/token-counter";
import { MetricsCollector } from "../../core/metrics";
import { createWriteStream } from "fs";
import { generateCacheKey } from "../shared/hash-utils";
import { join } from "path"; // ============================================================================// Type Definitions// ============================================================================export interface PerformanceTrackerOptions {  operation: 'track' | 'query' | 'analyze-trends' | 'forecast' |             'compare' | 'detect-regressions' | 'get-baseline' | 'generate-report';  // Tracking  metrics?: Array<{    name: string;    value: number;    unit?: string;    tags?: Record<string, string>;    timestamp?: number;  }>;  // Query options  query?: {    metrics: string[];    timeRange: { start: number; end: number };    filters?: Array<{ tag: string; value: any }>;    aggregation?: 'avg' | 'min' | 'max' | 'p50' | 'p90' | 'p95' | 'p99';  };  // Trend analysis  trendConfig?: {    metric: string;    period: number; // seconds    minDataPoints?: number;    sensitivity?: 'low' | 'medium' | 'high';  };  // Forecasting  forecastConfig?: {    metric: string;    horizon: number; // seconds into future    model?: 'linear' | 'exponential' | 'arima' | 'prophet';    confidence?: number; // 0-1  };  // Comparison  compareConfig?: {    metric: string;    baseline: { start: number; end: number };    current: { start: number; end: number };    threshold?: number; // % change to flag  };  // Regression detection  regressionConfig?: {    metrics?: string[];    window: number; // seconds    threshold: number; // % degradation    minOccurrences?: number;  };  // Baseline calculation  baselineConfig?: {    metric: string;    period: number; // seconds    percentile?: number;  };  // Report options  reportFormat?: 'markdown' | 'html' | 'pdf' | 'json';  includeCharts?: boolean;  // Cache options  useCache?: boolean;  cacheTTL?: number;}export interface PerformanceTrackerResult {  success: boolean;  data?: {    tracked?: { count: number; metrics: string[] };    metrics?: PerformanceMetric[];    trends?: TrendAnalysis[];    forecast?: ForecastResult;    comparison?: ComparisonResult;    regressions?: RegressionEvent[];    baseline?: BaselineMetrics;    report?: string | Buffer;  };  metadata: {    tokensUsed?: number;    tokensSaved?: number;    cacheHit: boolean;    metricsCount?: number;    timeRange?: { start: number; end: number };  };  error?: string;}// Performance Metric Typesexport interface PerformanceMetric {  name: string;  timestamp: number;  value: number;  unit?: string;  tags: Record<string, string>;  aggregated?: {    avg?: number;    min?: number;    max?: number;    p50?: number;    p90?: number;    p95?: number;    p99?: number;  };}// Trend Analysis Typesexport interface TrendAnalysis {  metric: string;  period: { start: number; end: number };  trend: 'increasing' | 'decreasing' | 'stable' | 'volatile';  direction: number; // slope  velocity: number; // rate of change  volatility: number; // variance  confidence: number;  dataPoints: number;  summary: string;}// Forecast Typesexport interface ForecastResult {  metric: string;  model: 'linear' | 'exponential' | 'arima' | 'prophet';  horizon: number;  predictions: ForecastPrediction[];  accuracy: {    mape?: number; // Mean Absolute Percentage Error    rmse?: number; // Root Mean Square Error    confidence: number;  };  generatedAt: number;}export interface ForecastPrediction {  timestamp: number;  value: number;  confidenceInterval: {    lower: number;    upper: number;  };}// Comparison Typesexport interface ComparisonResult {  metric: string;  baseline: {    period: { start: number; end: number };    value: number;    samples: number;  };  current: {    period: { start: number; end: number };    value: number;    samples: number;  };  change: {    absolute: number;    percentage: number;    significant: boolean;    threshold: number;  };  analysis: string;}// Regression Typesexport interface RegressionEvent {  metric: string;  detectedAt: number;  window: { start: number; end: number };  degradation: {    percentage: number;    absolute: number;  };  severity: 'minor' | 'moderate' | 'severe';  baseline: number;  current: number;  occurrences: number;  affectedPeriods: Array<{ start: number; end: number }>;}// Baseline Typesexport interface BaselineMetrics {  metric: string;  period: { start: number; end: number };  baseline: {    value: number;    percentile: number;    samples: number;  };  statistics: {    mean: number;    median: number;    stdDev: number;    min: number;    max: number;    p50: number;    p90: number;    p95: number;    p99: number;  };  calculatedAt: number;}// Internal Storage Typesinterface StoredMetric {  name: string;  timestamp: number;  value: number;  unit?: string;  tags: Record<string, string>;}interface AggregatedData {  values: number[];  sum: number;  count: number;  min: number;  max: number;}// ============================================================================// Main Implementation// ============================================================================export class PerformanceTracker {  private cache: CacheEngine;  private tokenCounter: TokenCounter;  private metricsCollector: MetricsCollector;  // In-memory storage for performance metrics  private metricsStore: Map<string, StoredMetric[]> = new Map();  private readonly MAXMETRICSPERNAME = 10000;  constructor(    cache: CacheEngine,    tokenCounter: TokenCounter,    metricsCollector: MetricsCollector  ) {    this.cache = cache;    this.tokenCounter = tokenCounter;    this.metricsCollector = metricsCollector;  }  /**   * Main entry point for performance tracking operations   */  async run(options: PerformanceTrackerOptions): Promise<PerformanceTrackerResult> {    const startTime = Date.now();    // Generate cache key    const cacheKey = generateCacheKey('performance-tracker', {        op: options.operation,        query: options.query,        trend: options.trendConfig,        forecast: options.forecastConfig,        compare: options.compareConfig,        regression: options.regressionConfig,        baseline: options.baselineConfig      });    // Check cache if enabled (except for track operation)    if (options.useCache !== false && options.operation !== 'track') {      const cached = this.cache.get(cacheKey);      if (cached) {        try {          const data = JSON.parse(cached.toString());          const tokensSaved = this.tokenCounter.count(JSON.stringify(data)).tokens;          this.metricsCollector.record({            operation: `performance-tracker:${options.operation}`,            duration: Date.now() - startTime,            success: true,            cacheHit: true,            savedTokens: tokensSaved          });          return {            success: true,            data,            metadata: {              tokensUsed: 0,              tokensSaved,              cacheHit: true,              timeRange: data.timeRange            }          };        } catch (error) {          // Cache parse error, continue with fresh execution        }      }    }    // Execute operation    let data: PerformanceTrackerResult['data'];    try {      switch (options.operation) {        case 'track':          data = await this.trackMetrics(options);          break;        case 'query':          data = await this.queryMetrics(options);          break;        case 'analyze-trends':          data = await this.analyzeTrends(options);          break;        case 'forecast':          data = await this.forecastPerformance(options);          break;        case 'compare':          data = await this.comparePerformance(options);          break;        case 'detect-regressions':          data = await this.detectRegressions(options);          break;        case 'get-baseline':          data = await this.getBaseline(options);          break;        case 'generate-report':          data = await this.generateReport(options);          break;        default:          throw new Error(`Unknown operation: ${options.operation}`);      }    } catch (error) {      const errorMsg = error instanceof Error ? error.message : String(error);      this.metricsCollector.record({        operation: `performance-tracker:${options.operation}`,        duration: Date.now() - startTime,        success: false,        cacheHit: false      });      return {        success: false,        data: {},        metadata: {          tokensUsed: 0,          tokensSaved: 0,          cacheHit: false        },        error: errorMsg      };    }    // Calculate tokens and cache result (except for track operation)    const tokensUsed = this.tokenCounter.count(JSON.stringify(data)).tokens;    if (options.operation !== 'track') {      const cacheTTL = this.getCacheTTL(options);      this.cache.set(cacheKey, JSON.stringify(data), tokensUsed, cacheTTL);    }    // Record metrics    this.metricsCollector.record({      operation: `performance-tracker:${options.operation}`,      duration: Date.now() - startTime,      success: true,      cacheHit: false,      inputTokens: tokensUsed    });    return {      success: true,      data,      metadata: {        tokensUsed,        tokensSaved: 0,        cacheHit: false,        metricsCount: this.getTotalMetricsCount()      }    };  }  // ============================================================================  // Track Operations  // ============================================================================  /**   * Track performance metrics   */  private async trackMetrics(options: PerformanceTrackerOptions): Promise<PerformanceTrackerResult['data']> {    if (!options.metrics || options.metrics.length === 0) {      throw new Error('No metrics provided for tracking');    }    const trackedMetrics: string[] = [];    const now = Date.now();    for (const metric of options.metrics) {      const storedMetric: StoredMetric = {        name: metric.name,        timestamp: metric.timestamp || now,        value: metric.value,        unit: metric.unit,        tags: metric.tags || {}      };      // Get or create metrics array for this name      let metricsArray = this.metricsStore.get(metric.name);      if (!metricsArray) {        metricsArray = [];        this.metricsStore.set(metric.name, metricsArray);      }      // Add metric and maintain size limit      metricsArray.push(storedMetric);      if (metricsArray.length > this.MAXMETRICSPERNAME) {        metricsArray.shift(); // Remove oldest      }      trackedMetrics.push(metric.name);    }    return {      tracked: {        count: options.metrics.length,        metrics: Array.from(new Set(trackedMetrics))      }    };  }  // ============================================================================  // Query Operations  // ============================================================================  /**   * Query performance metrics   */  private async queryMetrics(options: PerformanceTrackerOptions): Promise<PerformanceTrackerResult['data']> {    if (!options.query) {      throw new Error('Query configuration required');    }    const { metrics: metricNames, timeRange, filters, aggregation } = options.query;    const results: PerformanceMetric[] = [];    for (const metricName of metricNames) {      const metricsArray = this.metricsStore.get(metricName);      if (!metricsArray) continue;      // Filter by time range      let filtered = metricsArray.filter(m =>        m.timestamp >= timeRange.start && m.timestamp <= timeRange.end      );      // Apply tag filters      if (filters && filters.length > 0) {        filtered = filtered.filter(m =>          filters.every(f => m.tags[f.tag] === f.value)        );      }      if (filtered.length === 0) continue;      // Aggregate if requested      if (aggregation) {        const aggregated = this.aggregateMetrics(filtered, aggregation);        results.push({          name: metricName,          timestamp: timeRange.end,          value: aggregated.value,          unit: filtered[0].unit,          tags: {},          aggregated: aggregated.stats        });      } else {        // Return individual metrics (compressed for token reduction)        const compressed = this.compressMetrics(filtered);        results.push(...compressed);      }    }    return { metrics: results };  }  /**   * Aggregate metrics   */  private aggregateMetrics(    metrics: StoredMetric[],    type: 'avg' | 'min' | 'max' | 'p50' | 'p90' | 'p95' | 'p99'  ): { value: number; stats: PerformanceMetric['aggregated'] } {    const values = metrics.map(m => m.value).sort((a, b) => a - b);    const stats = {      avg: this.calculateAverage(values),      min: Math.min(...values),      max: Math.max(...values),      p50: this.calculatePercentile(values, 50),      p90: this.calculatePercentile(values, 90),      p95: this.calculatePercentile(values, 95),      p99: this.calculatePercentile(values, 99)    };    let value: number;    switch (type) {      case 'avg': value = stats.avg; break;      case 'min': value = stats.min; break;      case 'max': value = stats.max; break;      case 'p50': value = stats.p50; break;      case 'p90': value = stats.p90; break;      case 'p95': value = stats.p95; break;      case 'p99': value = stats.p99; break;    }    return { value, stats };  }  /**   * Compress metrics for token reduction   */  private compressMetrics(metrics: StoredMetric[]): PerformanceMetric[] {    // Group by time buckets (1-minute intervals) to reduce data points    const buckets = new Map<number, StoredMetric[]>();    metrics.forEach(m => {      const bucketKey = Math.floor(m.timestamp / 60000) * 60000;      if (!buckets.has(bucketKey)) {        buckets.set(bucketKey, []);      }      buckets.get(bucketKey)!.push(m);    });    // Aggregate each bucket    const compressed: PerformanceMetric[] = [];    for (const [timestamp, bucketMetrics] of buckets) {      const values = bucketMetrics.map(m => m.value);      compressed.push({        name: bucketMetrics[0].name,        timestamp,        value: this.calculateAverage(values),        unit: bucketMetrics[0].unit,        tags: bucketMetrics[0].tags      });    }    return compressed;  }  // ============================================================================  // Trend Analysis Operations  // ============================================================================  /**   * Analyze performance trends   */  private async analyzeTrends(options: PerformanceTrackerOptions): Promise<PerformanceTrackerResult['data']> {    if (!options.trendConfig) {      throw new Error('Trend configuration required');    }    const { metric, period, minDataPoints = 10, sensitivity = 'medium' } = options.trendConfig;    const metricsArray = this.metricsStore.get(metric);    if (!metricsArray || metricsArray.length < minDataPoints) {      throw new Error(`Insufficient data points for trend analysis (need at least ${minDataPoints})`);    }    const now = Date.now();    const startTime = now - (period * 1000);    // Filter metrics within period    const filtered = metricsArray.filter(m =>      m.timestamp >= startTime && m.timestamp <= now    );    if (filtered.length < minDataPoints) {      throw new Error(`Insufficient data points in period (found ${filtered.length}, need ${minDataPoints})`);    }    // Calculate trend statistics    const values = filtered.map(m => m.value);    const timestamps = filtered.map(m => m.timestamp);    // Linear regression for trend direction    const { slope, rSquared } = this.linearRegression(timestamps, values);    // Calculate volatility    const mean = this.calculateAverage(values);    const variance = values.reduce((sum, v) => sum + Math.pow(v - mean, 2), 0) / values.length;    const volatility = Math.sqrt(variance);    // Determine trend based on sensitivity    const thresholds = {      low: 0.01,      medium: 0.05,      high: 0.1    };    const threshold = thresholds[sensitivity];    const normalizedSlope = slope / mean;    let trend: TrendAnalysis['trend'];    if (Math.abs(normalizedSlope) < threshold) {      trend = 'stable';    } else if (volatility > mean * 0.5) {      trend = 'volatile';    } else if (slope > 0) {      trend = 'increasing';    } else {      trend = 'decreasing';    }    const analysis: TrendAnalysis = {      metric,      period: { start: startTime, end: now },      trend,      direction: slope,      velocity: normalizedSlope,      volatility,      confidence: rSquared,      dataPoints: filtered.length,      summary: this.generateTrendSummary(trend, slope, volatility, mean)    };    return { trends: [analysis] };  }  /**   * Generate trend summary   */  private generateTrendSummary(    trend: TrendAnalysis['trend'],    slope: number,    volatility: number,    mean: number  ): string {    const direction = slope > 0 ? 'upward' : 'downward';    const volatilityLevel = volatility > mean * 0.5 ? 'high' : volatility > mean * 0.2 ? 'moderate' : 'low';    switch (trend) {      case 'increasing':        return `Performance shows an ${direction} trend with ${volatilityLevel} volatility`;      case 'decreasing':        return `Performance shows a ${direction} trend with ${volatilityLevel} volatility`;      case 'stable':        return `Performance is stable with ${volatilityLevel} volatility`;      case 'volatile':        return `Performance is highly volatile with unpredictable fluctuations`;    }  }  // ============================================================================  // Forecasting Operations  // ============================================================================  /**   * Forecast future performance   */  private async forecastPerformance(options: PerformanceTrackerOptions): Promise<PerformanceTrackerResult['data']> {    if (!options.forecastConfig) {      throw new Error('Forecast configuration required');    }    const { metric, horizon, model = 'linear', confidence = 0.95 } = options.forecastConfig;    const metricsArray = this.metricsStore.get(metric);    if (!metricsArray || metricsArray.length < 10) {      throw new Error('Insufficient historical data for forecasting (need at least 10 points)');    }    // Sort by timestamp    const sorted = [...metricsArray].sort((a, b) => a.timestamp - b.timestamp);    const values = sorted.map(m => m.value);    const timestamps = sorted.map(m => m.timestamp);    // Generate forecast based on model    let forecast: ForecastResult;    switch (model) {      case 'linear':        forecast = this.forecastLinear(metric, timestamps, values, horizon, confidence);        break;      case 'exponential':        forecast = this.forecastExponential(metric, timestamps, values, horizon, confidence);        break;      case 'arima':        forecast = this.forecastARIMA(metric, timestamps, values, horizon, confidence);        break;      case 'prophet':        forecast = this.forecastProphet(metric, timestamps, values, horizon, confidence);        break;    }    return { forecast };  }  /**   * Linear forecast model   */  private forecastLinear(    metric: string,    timestamps: number[],    values: number[],    horizon: number,    confidence: number  ): ForecastResult {    const { slope, intercept, rSquared } = this.linearRegression(timestamps, values);    const lastTimestamp = timestamps[timestamps.length - 1];    // Calculate prediction error for confidence intervals    const predictions = timestamps.map(t => slope * (t - timestamps[0]) + intercept);    const errors = values.map((v, idx) => Math.abs(v - predictions[idx]));    const meanError = this.calculateAverage(errors);    const stdError = Math.sqrt(      errors.reduce((sum, e) => sum + Math.pow(e - meanError, 2), 0) / errors.length    );    // Generate future predictions    const numSteps = Math.ceil(horizon / 60); // 1-minute intervals    const step = horizon / numSteps;    const forecastPredictions: ForecastPrediction[] = [];    for (let i = 1; i <= numSteps; i++) {      const timestamp = lastTimestamp + (i * step * 1000);      const value = slope * (timestamp - timestamps[0]) + intercept;      const zScore = 1.96; // 95% confidence      const interval = zScore * stdError * Math.sqrt(1 + 1 / timestamps.length);      forecastPredictions.push({        timestamp,        value,        confidenceInterval: {          lower: value - interval,          upper: value + interval        }      });    }    return {      metric,      model: 'linear',      horizon,      predictions: forecastPredictions,      accuracy: {        rmse: stdError,        confidence: Math.min(confidence, rSquared)      },      generatedAt: Date.now()    };  }  /**   * Exponential forecast model (simplified exponential smoothing)   */  private forecastExponential(    metric: string,    timestamps: number[],    values: number[],    horizon: number,    confidence: number  ): ForecastResult {    const alpha = 0.3; // Smoothing factor    let smoothed = values[0];    const smoothedValues: number[] = [smoothed];    // Apply exponential smoothing    for (let i = 1; i < values.length; i++) {      smoothed = alpha * values[i] + (1 - alpha) * smoothed;      smoothedValues.push(smoothed);    }    // Calculate prediction error    const errors = values.map((v, i) => Math.abs(v - smoothedValues[i]));    const stdError = Math.sqrt(      errors.reduce((sum, e) => sum + Math.pow(e, 2), 0) / errors.length    );    const lastTimestamp = timestamps[timestamps.length - 1];    const lastValue = smoothedValues[smoothedValues.length - 1];    // Generate predictions (constant forecast with exponential smoothing)    const numSteps = Math.ceil(horizon / 60);    const step = horizon / numSteps;    const forecastPredictions: ForecastPrediction[] = [];    for (let i = 1; i <= numSteps; i++) {      const timestamp = lastTimestamp + (i * step * 1000);      const interval = 1.96 * stdError * Math.sqrt(i);      forecastPredictions.push({        timestamp,        value: lastValue,        confidenceInterval: {          lower: lastValue - interval,          upper: lastValue + interval        }      });    }    return {      metric,      model: 'exponential',      horizon,      predictions: forecastPredictions,      accuracy: {        rmse: stdError,        confidence: confidence * 0.9 // Slightly lower confidence      },      generatedAt: Date.now()    };  }  /**   * ARIMA forecast model (simplified autoregressive model)   */  private forecastARIMA(    metric: string,    timestamps: number[],    values: number[],    horizon: number,    confidence: number  ): ForecastResult {    // Simplified AR(1) model    const lag1Values = values.slice(0, -1);    const currentValues = values.slice(1);    // Calculate autocorrelation coefficient    const meanLag1 = this.calculateAverage(lag1Values);    const meanCurrent = this.calculateAverage(currentValues);    let numerator = 0;    let denominator = 0;    for (let i = 0; i < lag1Values.length; i++) {      numerator += (lag1Values[i] - meanLag1) * (currentValues[i] - meanCurrent);      denominator += Math.pow(lag1Values[i] - meanLag1, 2);    }    const phi = denominator !== 0 ? numerator / denominator : 0;    const intercept = meanCurrent - phi * meanLag1;    // Calculate residuals    const predictions = lag1Values.map((v) => phi * v + intercept);    const residuals = currentValues.map((v, i) => v - predictions[i]);    const stdError = Math.sqrt(      residuals.reduce((sum, r) => sum + Math.pow(r, 2), 0) / residuals.length    );    // Generate forecasts    const lastTimestamp = timestamps[timestamps.length - 1];    const lastValue = values[values.length - 1];    const numSteps = Math.ceil(horizon / 60);    const step = horizon / numSteps;    const forecastPredictions: ForecastPrediction[] = [];    let currentForecast = lastValue;    for (let i = 1; i <= numSteps; i++) {      const timestamp = lastTimestamp + (i * step * 1000);      currentForecast = phi * currentForecast + intercept;      const interval = 1.96 * stdError * Math.sqrt(i);      forecastPredictions.push({        timestamp,        value: currentForecast,        confidenceInterval: {          lower: currentForecast - interval,          upper: currentForecast + interval        }      });    }    return {      metric,      model: 'arima',      horizon,      predictions: forecastPredictions,      accuracy: {        rmse: stdError,        confidence: confidence * 0.85      },      generatedAt: Date.now()    };  }  /**   * Prophet forecast model (simplified trend + seasonality)   */  private forecastProphet(    metric: string,    timestamps: number[],    values: number[],    horizon: number,    confidence: number  ): ForecastResult {    // Calculate overall trend using linear regression    const { slope, intercept } = this.linearRegression(timestamps, values);    // Detect daily seasonality (24-hour pattern)    const hourlyPattern = new Array(24).fill(0);    const hourlyCounts = new Array(24).fill(0);    timestamps.forEach((t, i) => {      const hour = new Date(t).getHours();      hourlyPattern[hour] += values[i];      hourlyCounts[hour]++;    });    // Average seasonality by hour    const seasonality = hourlyPattern.map((sum, i) =>      hourlyCounts[i] > 0 ? sum / hourlyCounts[i] : 0    );    const seasonalityMean = this.calculateAverage(seasonality.filter(v => v > 0));    const normalizedSeasonality = seasonality.map(v => v - seasonalityMean);    // Calculate residuals    const trendValues = timestamps.map(t => slope * (t - timestamps[0]) + intercept);    const residuals = values.map((v, i) => {      const hour = new Date(timestamps[i]).getHours();      return v - trendValues[i] - normalizedSeasonality[hour];    });    const stdError = Math.sqrt(      residuals.reduce((sum, r) => sum + Math.pow(r, 2), 0) / residuals.length    );    // Generate forecasts    const lastTimestamp = timestamps[timestamps.length - 1];    const numSteps = Math.ceil(horizon / 60);    const step = horizon / numSteps;    const forecastPredictions: ForecastPrediction[] = [];    for (let i = 1; i <= numSteps; i++) {      const timestamp = lastTimestamp + (i * step * 1000);      const hour = new Date(timestamp).getHours();      const trendValue = slope * (timestamp - timestamps[0]) + intercept;      const seasonalValue = normalizedSeasonality[hour] || 0;      const value = trendValue + seasonalValue;      const interval = 1.96 * stdError * Math.sqrt(i);      forecastPredictions.push({        timestamp,        value,        confidenceInterval: {          lower: value - interval,          upper: value + interval        }      });    }    return {      metric,      model: 'prophet',      horizon,      predictions: forecastPredictions,      accuracy: {        rmse: stdError,        confidence: confidence * 0.95      },      generatedAt: Date.now()    };  }  // ============================================================================  // Comparison Operations  // ============================================================================  /**   * Compare performance across time periods   */  private async comparePerformance(options: PerformanceTrackerOptions): Promise<PerformanceTrackerResult['data']> {    if (!options.compareConfig) {      throw new Error('Comparison configuration required');    }    const { metric, baseline, current, threshold = 5 } = options.compareConfig;    const metricsArray = this.metricsStore.get(metric);    if (!metricsArray) {      throw new Error(`Metric ${metric} not found`);    }    // Get baseline period data    const baselineMetrics = metricsArray.filter(m =>      m.timestamp >= baseline.start && m.timestamp <= baseline.end    );    // Get current period data    const currentMetrics = metricsArray.filter(m =>      m.timestamp >= current.start && m.timestamp <= current.end    );    if (baselineMetrics.length === 0 || currentMetrics.length === 0) {      throw new Error('Insufficient data in one or both time periods');    }    // Calculate averages    const baselineValue = this.calculateAverage(baselineMetrics.map(m => m.value));    const currentValue = this.calculateAverage(currentMetrics.map(m => m.value));    // Calculate change    const absoluteChange = currentValue - baselineValue;    const percentageChange = (absoluteChange / baselineValue) * 100;    const significant = Math.abs(percentageChange) > threshold;    // Generate analysis    let analysis: string;    if (significant) {      if (percentageChange > 0) {        analysis = `Performance increased by ${percentageChange.toFixed(2)}% (above ${threshold}% threshold)`;      } else {        analysis = `Performance decreased by ${Math.abs(percentageChange).toFixed(2)}% (above ${threshold}% threshold)`;      }    } else {      analysis = `Performance change of ${percentageChange.toFixed(2)}% is within acceptable range`;    }    const comparison: ComparisonResult = {      metric,      baseline: {        period: baseline,        value: baselineValue,        samples: baselineMetrics.length      },      current: {        period: current,        value: currentValue,        samples: currentMetrics.length      },      change: {        absolute: absoluteChange,        percentage: percentageChange,        significant,        threshold      },      analysis    };    return { comparison };  }  // ============================================================================  // Regression Detection Operations  // ============================================================================  /**   * Detect performance regressions   */  private async detectRegressions(options: PerformanceTrackerOptions): Promise<PerformanceTrackerResult['data']> {    if (!options.regressionConfig) {      throw new Error('Regression configuration required');    }    const { metrics: metricNames, window, threshold, minOccurrences = 3 } = options.regressionConfig;    const regressions: RegressionEvent[] = [];    const now = Date.now();    const windowStart = now - (window * 1000);    // Use all metrics if not specified    const metricsToCheck = metricNames || Array.from(this.metricsStore.keys());    for (const metricName of metricsToCheck) {      const metricsArray = this.metricsStore.get(metricName);      if (!metricsArray) continue;      // Get metrics in window      const windowMetrics = metricsArray.filter(m =>        m.timestamp >= windowStart && m.timestamp <= now      );      if (windowMetrics.length < minOccurrences * 2) continue;      // Calculate baseline (first half of window)      const midpoint = windowStart + (window * 1000) / 2;      const baselineMetrics = windowMetrics.filter(m => m.timestamp < midpoint);      const recentMetrics = windowMetrics.filter(m => m.timestamp >= midpoint);      if (baselineMetrics.length < minOccurrences || recentMetrics.length < minOccurrences) {        continue;      }      const baselineValue = this.calculateAverage(baselineMetrics.map(m => m.value));      const recentValue = this.calculateAverage(recentMetrics.map(m => m.value));      // Check for degradation      const degradationPct = ((baselineValue - recentValue) / baselineValue) * 100;      if (degradationPct >= threshold) {        // Count affected periods        const affectedPeriods: Array<{ start: number; end: number }> = [];        const bucketSize = window * 1000 / 10; // 10 buckets        for (let i = 0; i < 10; i++) {          const bucketStart = windowStart + (i * bucketSize);          const bucketEnd = bucketStart + bucketSize;          const bucketMetrics = recentMetrics.filter(m =>            m.timestamp >= bucketStart && m.timestamp < bucketEnd          );          if (bucketMetrics.length > 0) {            const bucketAvg = this.calculateAverage(bucketMetrics.map(m => m.value));            if (((baselineValue - bucketAvg) / baselineValue) * 100 >= threshold) {              affectedPeriods.push({ start: bucketStart, end: bucketEnd });            }          }        }        const severity: RegressionEvent['severity'] =          degradationPct >= threshold * 2 ? 'severe' :          degradationPct >= threshold * 1.5 ? 'moderate' : 'minor';        regressions.push({          metric: metricName,          detectedAt: now,          window: { start: windowStart, end: now },          degradation: {            percentage: degradationPct,            absolute: baselineValue - recentValue          },          severity,          baseline: baselineValue,          current: recentValue,          occurrences: affectedPeriods.length,          affectedPeriods        });      }    }    return { regressions };  }  // ============================================================================  // Baseline Operations  // ============================================================================  /**   * Calculate performance baseline   */  private async getBaseline(options: PerformanceTrackerOptions): Promise<PerformanceTrackerResult['data']> {    if (!options.baselineConfig) {      throw new Error('Baseline configuration required');    }    const { metric, period, percentile = 95 } = options.baselineConfig;    const metricsArray = this.metricsStore.get(metric);    if (!metricsArray) {      throw new Error(`Metric ${metric} not found`);    }    const now = Date.now();    const startTime = now - (period * 1000);    // Filter metrics within period    const filtered = metricsArray.filter(m =>      m.timestamp >= startTime && m.timestamp <= now    );    if (filtered.length === 0) {      throw new Error('No data found in baseline period');    }    const values = filtered.map(m => m.value).sort((a, b) => a - b);    // Calculate statistics    const mean = this.calculateAverage(values);    const median = this.calculatePercentile(values, 50);    const stdDev = Math.sqrt(      values.reduce((sum, v) => sum + Math.pow(v - mean, 2), 0) / values.length    );    const baseline: BaselineMetrics = {      metric,      period: { start: startTime, end: now },      baseline: {        value: this.calculatePercentile(values, percentile),        percentile,        samples: filtered.length      },      statistics: {        mean,        median,        stdDev,        min: Math.min(...values),        max: Math.max(...values),        p50: this.calculatePercentile(values, 50),        p90: this.calculatePercentile(values, 90),        p95: this.calculatePercentile(values, 95),        p99: this.calculatePercentile(values, 99)      },      calculatedAt: now    };    return { baseline };  }  // ============================================================================  // Report Generation Operations  // ============================================================================  /**   * Generate performance report   */  private async generateReport(options: PerformanceTrackerOptions): Promise<PerformanceTrackerResult['data']> {    const format = options.reportFormat || 'markdown';    const includeCharts = options.includeCharts !== false;    const now = Date.now();    // Collect all metrics data    const allMetrics: string[] = Array.from(this.metricsStore.keys());    const reportData: any = {      generatedAt: new Date(now).toISOString(),      metrics: allMetrics,      summary: {}    };    // Generate summary for each metric    for (const metricName of allMetrics) {      const metricsArray = this.metricsStore.get(metricName);      if (!metricsArray || metricsArray.length === 0) continue;      const values = metricsArray.map(m => m.value);      reportData.summary[metricName] = {        count: values.length,        mean: this.calculateAverage(values),        min: Math.min(...values),        max: Math.max(...values),        latest: values[values.length - 1]      };    }    // Generate report based on format    let report: string | Buffer;    switch (format) {      case 'markdown':        report = this.generateMarkdownReport(reportData);        break;      case 'html':        report = this.generateHTMLReport(reportData, includeCharts);        break;      case 'json':        report = JSON.stringify(reportData, null, 2);        break;      case 'pdf':        throw new Error('PDF export not yet implemented');      default:        throw new Error(`Unknown report format: ${format}`);    }    return { report };  }  /**   * Generate Markdown report   */  private generateMarkdownReport(data: any): string {    let md = `# Performance Report\n\n`;    md += `Generated: ${data.generatedAt}\n\n`;    md += `## Metrics Summary\n\n`;    md += `Total Metrics: ${data.metrics.length}\n\n`;    md += `| Metric | Count | Mean | Min | Max | Latest |\n`;    md += `|--------|-------|------|-----|-----|--------|\n`;    for (const [metric, stats] of Object.entries(data.summary) as [string, any][]) {      md += `| ${metric} | ${stats.count} | ${stats.mean.toFixed(2)} | ${stats.min.toFixed(2)} | ${stats.max.toFixed(2)} | ${stats.latest.toFixed(2)} |\n`;    }    md += `\n## Recommendations\n\n`;    md += `- Monitor metrics with high variance\n`;    md += `- Set up alerts for performance degradation\n`;    md += `- Review baseline metrics regularly\n\n`;    return md;  }  /**   * Generate HTML report   */  private generateHTMLReport(data: any, includeCharts: boolean): string {    let html = `<!DOCTYPE html><html><head>  <title>Performance Report</title>  <style>    body { font-family: Arial, sans-serif; margin: 20px; }    h1 { color: #333; }    table { border-collapse: collapse; width: 100%; margin: 20px 0; }    th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }    th { background-color: #4CAF50; color: white; }    tr:nth-child(even) { background-color: #f2f2f2; }  </style></head><body>  <h1>Performance Report</h1>  <p>Generated: ${data.generatedAt}</p>  <h2>Metrics Summary</h2>  <p>Total Metrics: ${data.metrics.length}</p>  <table>    <tr>      <th>Metric</th>      <th>Count</th>      <th>Mean</th>      <th>Min</th>      <th>Max</th>      <th>Latest</th>    </tr>`;    for (const [metric, stats] of Object.entries(data.summary) as [string, any][]) {      html += `    <tr>      <td>${metric}</td>      <td>${stats.count}</td>      <td>${stats.mean.toFixed(2)}</td>      <td>${stats.min.toFixed(2)}</td>      <td>${stats.max.toFixed(2)}</td>      <td>${stats.latest.toFixed(2)}</td>    </tr>`;    }    html += `  </table>  <h2>Recommendations</h2>  <ul>    <li>Monitor metrics with high variance</li>    <li>Set up alerts for performance degradation</li>    <li>Review baseline metrics regularly</li>  </ul></body></html>`;    return html;  }  // ============================================================================  // Helper Methods  // ============================================================================  /**   * Calculate average of values   */  private calculateAverage(values: number[]): number {    if (values.length === 0) return 0;    return values.reduce((sum, v) => sum + v, 0) / values.length;  }  /**   * Calculate percentile   */  private calculatePercentile(sortedValues: number[], percentile: number): number {    if (sortedValues.length === 0) return 0;    const index = Math.ceil((percentile / 100) * sortedValues.length) - 1;    return sortedValues[Math.max(0, index)];  }  /**   * Linear regression   */  private linearRegression(    x: number[],    y: number[]  ): { slope: number; intercept: number; rSquared: number } {    const n = x.length;    if (n === 0) return { slope: 0, intercept: 0, rSquared: 0 };    const sumX = x.reduce((a, b) => a + b, 0);    const sumY = y.reduce((a, b) => a + b, 0);    const sumXY = x.reduce((sum, xi, i) => sum + xi * y[i], 0);    const sumX2 = x.reduce((sum, xi) => sum + xi * xi, 0);    const sumY2 = y.reduce((sum, yi) => sum + yi * yi, 0);    const slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);    const intercept = (sumY - slope * sumX) / n;    // Calculate R-squared    const yMean = sumY / n;    const ssTotal = y.reduce((sum, yi) => sum + Math.pow(yi - yMean, 2), 0);    const ssResidual = y.reduce((sum, yi, i) => {      const predicted = slope * x[i] + intercept;      return sum + Math.pow(yi - predicted, 2);    }, 0);    const rSquared = 1 - (ssResidual / ssTotal);    return { slope, intercept, rSquared };  }  /**   * Get cache TTL based on operation   */  private getCacheTTL(options: PerformanceTrackerOptions): number {    if (options.cacheTTL) return options.cacheTTL;    // Default TTLs based on operation (token reduction technique)    switch (options.operation) {      case 'query':        return 60; // 1 minute      case 'analyze-trends':        return 3600; // 1 hour      case 'forecast':        return 7200; // 2 hours (forecast results are expensive to compute)      case 'compare':        return 1800; // 30 minutes      case 'detect-regressions':        return 600; // 10 minutes      case 'get-baseline':        return 3600; // 1 hour      case 'generate-report':        return 1800; // 30 minutes      default:        return 300; // 5 minutes default    }  }  /**   * Get total metrics count   */  private getTotalMetricsCount(): number {    let total = 0;    for (const metricsArray of this.metricsStore.values()) {      total += metricsArray.length;    }    return total;  }}// ============================================================================// MCP Tool Definition// ============================================================================export const PERFORMANCETRACKERTOOL = {  name: 'performancetracker',  description: 'Track and analyze performance metrics with trend detection, forecasting, and regression analysis',  inputSchema: {    type: 'object',    properties: {      operation: {        type: 'string',        enum: ['track', 'query', 'analyze-trends', 'forecast', 'compare', 'detect-regressions', 'get-baseline', 'generate-report'],        description: 'Performance tracking operation to perform'      },      metrics: {        type: 'array',        items: {          type: 'object',          properties: {            name: { type: 'string' },            value: { type: 'number' },            unit: { type: 'string' },            tags: { type: 'object' },            timestamp: { type: 'number' }          },          required: ['name', 'value']        },        description: 'Metrics to track (for track operation)'      },      query: {        type: 'object',        properties: {          metrics: { type: 'array', items: { type: 'string' } },          timeRange: {            type: 'object',            properties: {              start: { type: 'number' },              end: { type: 'number' }            },            required: ['start', 'end']          },          filters: { type: 'array' },          aggregation: {            type: 'string',            enum: ['avg', 'min', 'max', 'p50', 'p90', 'p95', 'p99']          }        },        description: 'Query configuration'      },      trendConfig: {        type: 'object',        properties: {          metric: { type: 'string' },          period: { type: 'number' },          minDataPoints: { type: 'number' },          sensitivity: {            type: 'string',            enum: ['low', 'medium', 'high']          }        },        description: 'Trend analysis configuration'      },      forecastConfig: {        type: 'object',        properties: {          metric: { type: 'string' },          horizon: { type: 'number' },          model: {            type: 'string',            enum: ['linear', 'exponential', 'arima', 'prophet']          },          confidence: { type: 'number' }        },        description: 'Forecast configuration'      },      compareConfig: {        type: 'object',        properties: {          metric: { type: 'string' },          baseline: {            type: 'object',            properties: {              start: { type: 'number' },              end: { type: 'number' }            }          },          current: {            type: 'object',            properties: {              start: { type: 'number' },              end: { type: 'number' }            }          },          threshold: { type: 'number' }        },        description: 'Comparison configuration'      },      regressionConfig: {        type: 'object',        properties: {          metrics: { type: 'array', items: { type: 'string' } },          window: { type: 'number' },          threshold: { type: 'number' },          minOccurrences: { type: 'number' }        },        description: 'Regression detection configuration'      },      baselineConfig: {        type: 'object',        properties: {          metric: { type: 'string' },          period: { type: 'number' },          percentile: { type: 'number' }        },        description: 'Baseline calculation configuration'      },      reportFormat: {        type: 'string',        enum: ['markdown', 'html', 'pdf', 'json'],        description: 'Report output format'      },      includeCharts: {        type: 'boolean',        description: 'Include charts in report',        default: true      },      useCache: {        type: 'boolean',        description: 'Enable caching of results',        default: true      },      cacheTTL: {        type: 'number',        description: 'Cache TTL in seconds'      }    },    required: ['operation']  }} as const;// ============================================================================// MCP Tool Runner// ============================================================================export async function runPerformanceTracker(  options: PerformanceTrackerOptions): Promise<PerformanceTrackerResult> {  const cache = new CacheEngine();  const tokenCounter = new TokenCounter();  const metricsCollector = new MetricsCollector();  const tool = new PerformanceTracker(cache, tokenCounter, metricsCollector);  return await tool.run(options);}
