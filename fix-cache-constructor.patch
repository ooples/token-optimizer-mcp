--- a/src/core/cache-engine.ts
+++ b/src/core/cache-engine.ts
@@ -27,6 +27,7 @@ export interface CacheStats {
 export class CacheEngine {
   private db: Database.Database;
   private memoryCache: LRUCache<string, string>;
+  private dbPath: string;
   private stats = {
     hits: 0,
     misses: 0,
@@ -45,69 +46,85 @@ export class CacheEngine {
       fs.mkdirSync(cacheDir, { recursive: true });
     }

-    const fullDbPath = dbPath || path.join(cacheDir, 'cache.db');
+    const finalDbPath = dbPath || path.join(cacheDir, 'cache.db');

-    // Initialize SQLite database with corruption handling
-    try {
-      this.db = new Database(fullDbPath);
-      this.db.pragma('journal_mode = WAL'); // Write-Ahead Logging for better concurrency
+    // Retry logic with up to 3 attempts
+    let lastError: Error | null = null;
+    const maxAttempts = 3;
+    let dbInitialized = false;

-      // Create cache table if it doesn't exist
-      this.db.exec(`
-        CREATE TABLE IF NOT EXISTS cache (
-          key TEXT PRIMARY KEY,
-          value TEXT NOT NULL,
-          compressed_size INTEGER NOT NULL,
-          original_size INTEGER NOT NULL,
-          hit_count INTEGER DEFAULT 0,
-          created_at INTEGER NOT NULL,
-          last_accessed_at INTEGER NOT NULL
-        );
+    for (let attempt = 1; attempt <= maxAttempts; attempt++) {
+      try {
+        // First attempt: use requested path
+        // Second attempt: try cleaning up corrupted files and retry
+        // Third attempt: use backup location in temp directory
+        const dbPathToUse =
+          attempt === 3
+            ? path.join(
+                os.tmpdir(),
+                `token-optimizer-cache-backup-${Date.now()}.db`
+              )
+            : finalDbPath;

-        CREATE INDEX IF NOT EXISTS idx_last_accessed ON cache(last_accessed_at);
-        CREATE INDEX IF NOT EXISTS idx_hit_count ON cache(hit_count);
-      `);
-    } catch (error) {
-      // If database is corrupted, close it (if it was opened), delete it and create a new one
-      try {
-        // Try to close the database if it was partially opened
-        if ((this as any).db) {
-          (this as any).db.close();
+        // If this is attempt 2, try to clean up corrupted files
+        if (attempt === 2 && fs.existsSync(finalDbPath)) {
+          try {
+            fs.unlinkSync(finalDbPath);
+            // Also remove WAL files
+            const walPath = `${finalDbPath}-wal`;
+            const shmPath = `${finalDbPath}-shm`;
+            if (fs.existsSync(walPath)) fs.unlinkSync(walPath);
+            if (fs.existsSync(shmPath)) fs.unlinkSync(shmPath);
+          } catch (cleanupError) {
+            // If we can't clean up, we'll try temp directory on next attempt
+          }
         }
-      } catch (closeError) {
-        // Ignore close errors
-      }

-      if (fs.existsSync(fullDbPath)) {
+        this.db = new Database(dbPathToUse);
+        this.db.pragma('journal_mode = WAL');
+
+        // Create cache table if it doesn't exist
+        this.db.exec(`
+          CREATE TABLE IF NOT EXISTS cache (
+            key TEXT PRIMARY KEY,
+            value TEXT NOT NULL,
+            compressed_size INTEGER NOT NULL,
+            original_size INTEGER NOT NULL,
+            hit_count INTEGER DEFAULT 0,
+            created_at INTEGER NOT NULL,
+            last_accessed_at INTEGER NOT NULL
+          );
+
+          CREATE INDEX IF NOT EXISTS idx_last_accessed ON cache(last_accessed_at);
+          CREATE INDEX IF NOT EXISTS idx_hit_count ON cache(hit_count);
+        `);
+
+        // Success! Store the path we used
+        this.dbPath = dbPathToUse;
+        dbInitialized = true;
+        break;
+      } catch (error) {
+        lastError = error instanceof Error ? error : new Error(String(error));
+
+        // Try to close the database if it was partially opened
         try {
-          fs.unlinkSync(fullDbPath);
-          // Also remove WAL files
-          const walPath = `${fullDbPath}-wal`;
-          const shmPath = `${fullDbPath}-shm`;
-          if (fs.existsSync(walPath)) fs.unlinkSync(walPath);
-          if (fs.existsSync(shmPath)) fs.unlinkSync(shmPath);
-        } catch (unlinkError) {
-          // Ignore errors during cleanup
+          if ((this as any).db) {
+            (this as any).db.close();
+          }
+        } catch (closeError) {
+          // Ignore close errors
+        }
+
+        if (attempt < maxAttempts) {
+          // Log warning and try next attempt
+          console.warn(
+            `Cache database initialization attempt ${attempt}/${maxAttempts} failed:`,
+            error
+          );
+          console.warn(`Retrying... (attempt ${attempt + 1}/${maxAttempts})`);
         }
       }
-
-      // Create a fresh database
-      this.db = new Database(fullDbPath);
-      this.db.pragma('journal_mode = WAL');
-      this.db.exec(`
-        CREATE TABLE IF NOT EXISTS cache (
-          key TEXT PRIMARY KEY,
-          value TEXT NOT NULL,
-          compressed_size INTEGER NOT NULL,
-          original_size INTEGER NOT NULL,
-          hit_count INTEGER DEFAULT 0,
-          created_at INTEGER NOT NULL,
-          last_accessed_at INTEGER NOT NULL
-        );
-
-        CREATE INDEX IF NOT EXISTS idx_last_accessed ON cache(last_accessed_at);
-        CREATE INDEX IF NOT EXISTS idx_hit_count ON cache(hit_count);
-      `);
+    }
+
+    // If all attempts failed, throw a comprehensive error
+    if (!dbInitialized) {
+      throw new Error(
+        `Failed to initialize cache database after ${maxAttempts} attempts. ` +
+          `Last error: ${lastError?.message || 'Unknown error'}. ` +
+          `Attempted paths: ${finalDbPath}, backup location. ` +
+          `Please check disk space and file permissions.`
+      );
     }

     // Initialize in-memory LRU cache for frequently accessed items
